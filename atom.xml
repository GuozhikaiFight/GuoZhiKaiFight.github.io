<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gker&#39;s blog</title>
  
  
  <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/atom.xml" rel="self"/>
  
  <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/"/>
  <updated>2022-06-16T13:04:00.648Z</updated>
  <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/</id>
  
  <author>
    <name>GuoZhiKai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PS学习笔记</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/16/PS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/16/PS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-06-16T13:03:20.000Z</published>
    <updated>2022-06-16T13:04:00.648Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="PS笔记"><a href="#PS笔记" class="headerlink" title="PS笔记"></a>PS笔记</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-06-16T11:57:46.000Z</published>
    <updated>2022-06-16T11:58:48.392Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="我们所谈论的面向对象到底是什么？"><a href="#我们所谈论的面向对象到底是什么？" class="headerlink" title="我们所谈论的面向对象到底是什么？"></a>我们所谈论的面向对象到底是什么？</h2><h3 id="OOP与OOPL"><a href="#OOP与OOPL" class="headerlink" title="OOP与OOPL"></a>OOP与OOPL</h3><blockquote><ul><li>OOP  (Object Oriented Programming) 面向对象编程<blockquote><ul><li>面向对象编程是一种以类或对象作为组织代码基本单元的编程范式或编程风格，并将继承、封装、多态、抽象四个特性作为代码设计和实现的基石</li></ul></blockquote></li><li>OOPL (Object Oriented Programming Language ) 面向对象编程语言<blockquote><ul><li>OOPL是支持类或对象的语法机制，能方便地实现面向对象编程四大特性的编程语言</li></ul></blockquote></li><li>OOP与OOPL之间没有充分必要的关联，OOP不都是通过OOPL来进行，OOPL写出的代码也不一定都是OOP编程风格</li><li>非严格意义上来讲，只要某种编程语言支持类或对象的语法概念，并以此为组织代码的基本单元，便可以粗略认为它就是面向对象的编程语言。</li></ul></blockquote><hr><h2 id="面向对象分析（OOA）与面向对象设计-OOD"><a href="#面向对象分析（OOA）与面向对象设计-OOD" class="headerlink" title="面向对象分析（OOA）与面向对象设计(OOD)"></a>面向对象分析（OOA）与面向对象设计(OOD)</h2><blockquote><ul><li>面向对象软件开发的三个阶段 OOA 分析 -》OOD 设计 -》OOP 实现</li><li>围绕对象与类进行需求的分析与设计，分析与设计最终产出的是类的设计，程序可被拆解为哪些类、类与类之间如何交互等等。</li></ul></blockquote><hr><h2 id="封装、继承、多态、抽象解决了哪些编程问题"><a href="#封装、继承、多态、抽象解决了哪些编程问题" class="headerlink" title="封装、继承、多态、抽象解决了哪些编程问题"></a>封装、继承、多态、抽象解决了哪些编程问题</h2><h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a>封装(Encapsulation)</h3><blockquote><ul><li>封装也叫做信息隐藏或者数据访问保护，类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。</li><li>封装需要编程语言本身提供一定的语法机制（访问权限控制）来进行支持</li><li>访问权限控制：Java中是访问权限修饰符 public protected private default</li></ul></blockquote><table><thead><tr><th>修饰符</th><th>同类</th><th>同包</th><th>子类</th><th>不同包</th></tr></thead><tbody><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>/</td></tr><tr><td>default</td><td>Y</td><td>Y</td><td>/</td><td>/</td></tr><tr><td>private</td><td>Y</td><td>/</td><td>/</td><td>/</td></tr></tbody></table><h3 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h3><blockquote><ul><li>若类中的属性不存在访问权限控制，那么任何人都可对类中的属性进行篡改</li><li>封装将相关业务逻辑实现细节进行隐藏，相关业务调用者只需要调用特定的方法即可完成业务。</li></ul></blockquote><hr><h3 id="抽象-Abstraction"><a href="#抽象-Abstraction" class="headerlink" title="抽象(Abstraction)"></a>抽象(Abstraction)</h3><blockquote><ul><li>抽象相对于封装来讲，是将方法的实现细节进行隐藏，调用者只需关心提供了哪些方法，并不需要知道这些功能如何实现的。</li><li>Java中通过 interface 与 abstract 关键字实现抽象</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPictureStorage</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">savePicture</span><span class="params">(Picture picture)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PictureStorage</span> <span class="keyword">implements</span> <span class="title class_">IPictureStorage</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">savePicture</span><span class="params">(Picture picture)</span>&#123;.....&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>抽象只需要提供“函数”语法机制就可以实现抽象的特性，“函数”包裹具体的实现逻辑，这本身就是一种抽象，调用者不需要去研究函数内部的实现逻辑，并没有很强的“特异性”所以有时候并不被看做是面向对象的特性。</li></ul></blockquote><h3 id="抽象的意义"><a href="#抽象的意义" class="headerlink" title="抽象的意义"></a>抽象的意义</h3><blockquote><ul><li>抽象可以只关注于功能点，不关注实现的设计思路可以有效忽略一些非关键性的实现细节。</li><li>在定义或命名类的方法时，不需要暴露太多细节，例如getAliyunPictureUrl()叫做getPictureUrl() 当要改变实现逻辑时不需要修改或重命名方法名称。</li></ul></blockquote><hr><h3 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h3><blockquote><ul><li>用于描述 is-a关系，猫是一种哺乳动物，继承可分为单继承与多继承，可单独继承一个父类或继承多个父类。</li><li>各个编程语言中实现继承特性的语法机制：<blockquote><ol><li>Java extends</li><li>C++,C#  :</li><li>Pyhton paraentheses()</li><li>Ruby &lt;</li></ol></blockquote></li><li>单继承语言 Java PHP C# Ruby 多继承语言 C++ Python 。。</li></ul></blockquote><h3 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义"></a>继承的意义</h3><blockquote><ul><li>实现代码复用</li><li>使用继承过多会导致代码可读性变差，可维护性变差，子类和父类高度藕合，修改父类会影响到子类</li></ul></blockquote><h3 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h3><blockquote><ul><li>子类代替父类</li><li>java中实现多态需要的三个语法机制</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicArray</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;父类add方法&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortedDynamicArray</span> <span class="keyword">extends</span> <span class="title class_">DynamicArray</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.print(<span class="string">&quot;子类add方法&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">DynamicArray</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortedDynamicArray</span>();</span><br><span class="line">        test.add();<span class="comment">//子类add方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><ol><li>支持父类对象可引用子类</li><li>支持继承</li><li>支持子类重写(Override)父类中的方法</li></ol></blockquote><ul><li>接口实现多态</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">    String <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class Array <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span>&#123;..........&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span>&#123;..........&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class LinkedList  <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span>&#123;..........&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">remove</span><span class="params">()</span>&#123;..........&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">demo</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">        demo.next();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">demo2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        demo2.next();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>继承或接口实现多态在java中需要一是有类与类之间存在继承关系，需实现其接口。</li></ul></blockquote><h3 id="多态的意义"><a href="#多态的意义" class="headerlink" title="多态的意义"></a>多态的意义</h3><blockquote><ul><li>可提高代码的可扩展性与复用性</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象、设计原则、设计模式、编编程规范、重构，五者之间的关系</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%BC%96%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E3%80%81%E9%87%8D%E6%9E%84%EF%BC%8C%E4%BA%94%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/14/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81%E7%BC%96%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E3%80%81%E9%87%8D%E6%9E%84%EF%BC%8C%E4%BA%94%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</id>
    <published>2022-06-14T11:30:09.000Z</published>
    <updated>2022-06-16T11:58:00.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="主流编程范式或者编程风格"><a href="#主流编程范式或者编程风格" class="headerlink" title="主流编程范式或者编程风格"></a>主流编程范式或者编程风格</h2><blockquote><ol><li>面向过程</li><li>面向对象</li><li>函数式编程</li></ol><ul><li>面向对象编程因其具有丰富的特性【封装、继承、多态、抽象】，是实现很多设计原则与设计模式的基础。</li></ul></blockquote><hr><h2 id="面向对象七大知识点"><a href="#面向对象七大知识点" class="headerlink" title="面向对象七大知识点"></a>面向对象七大知识点</h2><blockquote><ol><li>面向对象四大特性:继承、封装、多态、抽象</li><li>面向对象编程与面向过程编程的区别与联系</li><li>面向对象分析、面向对象设计、面向对象编程</li><li>接口和抽象类的区别以及各自的应用场景</li><li>基于接口而非实现编程的设计思想</li><li>多用组合少用继承的设计思想</li><li>面向过程的贫血模型和面向对象的充血模型</li></ol></blockquote><hr><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><blockquote><ol><li>SOLID原则-SRP单一职责原则</li><li>SOLID原则-OCP开闭原则</li><li>SOLID原则-LSP里氏替换原则</li><li>SOLID原则-ISP接口隔离原则</li><li>SOLID原则-DIP依赖倒置原则</li><li>DRY原则、KISS原则、YAGNI原则、LOD法则</li></ol></blockquote><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><ul><li>一套解决方案或者设计思路，大部分设计模式要解决的都是代码的可拓展性问题。</li><li>经典的设计的模式有23种，随着编程语言的演进，一些设计模式（Singleton）随之过时，甚至成了反模式，当然也诞生了新的设计模式。</li><li>设计模式可分为三种类型<blockquote><ol><li>创建型<blockquote><ul><li>常用的： 单例模式、工厂模式、建造者模式</li><li>不常用的： 原型模式</li></ul></blockquote></li><li>结构型<blockquote><ul><li>常用的： 代理模式、桥接模式、装饰者模式、适配器模式</li><li>不常用的： 门面模式、组合模式、享元模式</li></ul></blockquote></li><li>行为型<blockquote><ul><li>常用的： 观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式</li><li>不常用的： 访问者模式、备忘录模式、命令模式、解释器模式、中介模式</li></ul></blockquote></li></ol></blockquote></li></ul></blockquote><hr><h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><blockquote><ul><li>代码编写范式</li></ul></blockquote><hr><h2 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h2><blockquote><ul><li>随着需求的变化，为解决原有设计出现的问题，可使用上述提到的面向对象设计思想、设计原则、设计模式、编码规范进行代码重构</li><li>重构的知识点<blockquote><ol><li>重构的目的（why）、对象（what）、时机（when）、方法（how）</li><li>保证重构不出错的手段：单元测试和代码的可测试性</li><li>不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）</li></ol></blockquote></li></ul></blockquote><hr><h2 id="五者之间的联系"><a href="#五者之间的联系" class="headerlink" title="五者之间的联系"></a>五者之间的联系</h2><blockquote><ul><li>面向对象编程为设计原则、设计模式提供实现编码的基础</li><li>设计原则是指导编码设计的经验总结，相对抽象</li><li>设计模式是相对设计原则来讲相对具体的解决方案与设计思路</li><li>编程规范主要解决代码可读性，偏重于代码细节</li><li>重构是保证代码质量不下降的有效手段，利用上述四点进行重构</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-链表</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</id>
    <published>2022-06-11T02:43:38.000Z</published>
    <updated>2022-06-11T02:44:16.590Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h2><blockquote><ul><li>各种缓存<blockquote><ol><li>CPU缓存</li><li>数据库缓存</li><li>浏览器缓存</li></ol></blockquote></li><li>缓存淘汰策略 (缓存总有满的时候，满了咋清理)<blockquote><ul><li>先进先出策略FIFO(first in ,first out)</li><li>最少使用策略LFU(Least Frequently Used)</li><li>最近最少使用策略LRU(Least Recently Used)</li></ul></blockquote></li></ul></blockquote><hr><h2 id="数组与链表区别"><a href="#数组与链表区别" class="headerlink" title="数组与链表区别"></a>数组与链表区别</h2><blockquote><ol><li>底层存储结构<blockquote><ul><li>数组对于内存的要求比较高，当内存总没有连续的，足够大的存储空间时，即便内存的剩余总量大于申请的空间，也会申请失败。</li><li>链表相反，不需要连续的内存空间来存储数据，通过“指针”，将零散的内存串联起来使用。</li></ul></blockquote></li></ol></blockquote><hr><h2 id="链表的常见数据结构"><a href="#链表的常见数据结构" class="headerlink" title="链表的常见数据结构"></a>链表的常见数据结构</h2><blockquote><ol><li>单链表<blockquote><ul><li>链表通过指针将一组零散的内存块串联在一起，其中，我们把内存块成为链表的结点，将各个单独的内存块串联起来，内存块中除了存储数据，还需要记录链上的下一个结点地址，下个结点地址的指针叫作后继指针next</li></ul></blockquote></li></ol></blockquote><div style="text-align:center" >    <image src="https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg" style="width:600px;"></div><blockquote><ul><li>链表结构中最开始的结点叫作头结点，最后一个结点叫作尾结点，头结点记录链表的基地址，尾结点指针指向空地址null</li><li>链表中插入与删除数据，不需要为了内存的连续性而搬移结点，只需要考虑相邻结点的指针改变，所以对应的时间复杂度为O(1)</li><li>链表中随机访问元素时，无法做到数组那样，需要根据指针一个结点一个结点依次遍历，时间复杂度为O(n)</li></ul><ol start="2"><li>循环链表</li></ol></blockquote><div style="text-align:center" >    <image src="https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg" style="width:600px;"></div><blockquote><blockquote><ul><li>循环链表是特殊的单链表，特殊性在于尾结点指向的地址为头结点，首尾结点相连。</li></ul><ol start="3"><li>双向链表</li></ol></blockquote></blockquote><div style="text-align:center" >    <image src="https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg" style="width:600px;"></div><blockquote><blockquote><ul><li>双向链表支持前后两个方向，每个结点不止有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。</li><li>双向链表因需要提供两个额外的空间存储后继节点与前驱结点地址，多以比单向链表更占用空间，可支持双向遍历。</li></ul><ol start="4"><li>双向循环链表</li></ol></blockquote></blockquote><div style="text-align:center" >    <image src="https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg" style="width:600px;"></div><hr><h2 id="链表中的删除与插入操作再分析"><a href="#链表中的删除与插入操作再分析" class="headerlink" title="链表中的删除与插入操作再分析"></a>链表中的删除与插入操作再分析</h2><blockquote><ul><li>之前所分析的链表中删除、插入操作只需更改相邻结点数据，时间复杂度为O(1)</li><li>实际从链表中删除一个数据有两种情况<blockquote><ol><li>删除结点中“值等于某个给定值”的结点  <blockquote><ul><li>给定值的情况下，单链表，双向链表，仅删除操作的时间复杂度为O(1),但查找到该值的时间复杂度为O(n)</li></ul></blockquote></li><li>删除给定指针指向的结点<blockquote><ul><li>对于单向链表来讲，删除给定结点需要找到该结点的前驱结点，时间复杂度为O(n),双向链表因其结点中保存有前驱结点，不需要像单向链表一样遍历，所以删除操作时间复杂度为O(1)</li></ul></blockquote></li></ol></blockquote></li><li>插入操作，双向链表时间复杂度为O(1)，单向链表时间复杂度为O(n)</li><li>双向链表应用：java中的LinkedHashMap容器</li></ul></blockquote><hr><h2 id="以空间换时间，以时间换空间"><a href="#以空间换时间，以时间换空间" class="headerlink" title="以空间换时间，以时间换空间"></a>以空间换时间，以时间换空间</h2><blockquote><ul><li>当内存空间充足，并且追求代码更加快的执行速度时，可采用空间复杂度相对高，但时间复杂度相对低的算法与数据结构，相反，空间不足时，需要对时间进行牺牲。</li></ul></blockquote><hr><h2 id="数组与链表数据结构性能比拼"><a href="#数组与链表数据结构性能比拼" class="headerlink" title="数组与链表数据结构性能比拼"></a>数组与链表数据结构性能比拼</h2><blockquote><ol><li>数组的缺点是固定大小，一经声明需要占用连续的内存空间，当声明的数组过大时，系统中没有足够的内存为其分配，则会导致内存不足(OOM)，链表本身无内存大小限制，天然地支持动态扩容。</li><li>数组使用的是连续的内存空间，可借助CPU缓存机制预读数组中的数据，所以访问效率更高，加载某个下标的时候，可以把以后的几个下标元素也加载到CPU缓存，链表因其使用的不是连续的内存空间，无法有效预读。</li></ol></blockquote><hr><h2 id="LRU缓存淘汰算法基于链表实现"><a href="#LRU缓存淘汰算法基于链表实现" class="headerlink" title="LRU缓存淘汰算法基于链表实现"></a>LRU缓存淘汰算法基于链表实现</h2><blockquote><ul><li>维护一个有序单链表，越靠近尾部的结点是越早之前访问的，当新数据被访问时，从链表头部开始遍历。</li><li>若此数据之前被缓存，需遍历得到这个数据对应的结点，并删除，再将数据插入到链表头部。</li><li>若此数据之前不存在链表中，当缓存未满时，直接插入到头部，当缓存已满时，链表尾部结点删除，新数据插入头部。</li></ul></blockquote><hr><h2 id="如何判断一个字符串是否是回文字符串"><a href="#如何判断一个字符串是否是回文字符串" class="headerlink" title="如何判断一个字符串是否是回文字符串"></a>如何判断一个字符串是否是回文字符串</h2><blockquote><ul><li>回文字符串是正读、反读都一样的字符串。</li><li></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-数组</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/</id>
    <published>2022-06-09T08:39:13.000Z</published>
    <updated>2022-06-11T00:13:52.952Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="何为数组？"><a href="#何为数组？" class="headerlink" title="何为数组？"></a>何为数组？</h2><blockquote><ul><li>数组Array是一种 <strong>线性表</strong>数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据<blockquote><ul><li>线性表(Linear List)：数据排成一条线一样的结构，每个线性表上的数据最多有前和后两个方向，链表、队列、栈等都为线性表结构。<br><img src="https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg" class="lazyload" data-srcset="https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>非线性表：数据之间并不是简单的前后关系 二叉树、堆等<br><img src="https://static001.geekbang.org/resource/image/6e/69/6ebf42641b5f98f912d36f6bf86f6569.jpg" class="lazyload" data-srcset="https://static001.geekbang.org/resource/image/6e/69/6ebf42641b5f98f912d36f6bf86f6569.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ul></blockquote></li><li>连续的内存空间与相同的数据类型<blockquote><ul><li>数组可以进行随机访问的特性原因</li><li>优势：可随机按照数组下标进行随机访问元素</li><li>劣势：连续的内存空间导致元素的删除、插入需要进行大量的数据搬移工作</li></ul></blockquote></li></ul></blockquote><hr><h2 id="数组如何实现的随机访问？"><a href="#数组如何实现的随机访问？" class="headerlink" title="数组如何实现的随机访问？"></a>数组如何实现的随机访问？</h2><blockquote><ul><li>上边有数据可随机访问特性的原因，</li><li>针对数组中的连续内存单元，会为其内存单元分配一个地址，计算机通过地址来访问内存中的数据，当计算机需要随机访问数组中某个元素时，需要通过寻址公式计算该元素的内存地址。<br></li></ul></blockquote><hr><h2 id="寻址公式"><a href="#寻址公式" class="headerlink" title="寻址公式"></a>寻址公式</h2><blockquote><ul><li>一维数组寻址公式 a[i]_address = base_address + i * data_type_size :data_type_size 由数组中存储的数据类型字节决定。</li><li>二维数组寻址公式推导：有二维数组 arr[m][k] 数组下标分别为 i j 且 i &lt; m  , j &lt; m <blockquote><ul><li>二维数组本身存放的内容为多个一维数组，且分配的内存空间也是连续的，以arr[2][2]为例 <br><br>{1,2},<br><br>{3,4}<br><br>存放的四个数内下标访问为<br><br>arr[0][0]=1<br><br>arr[0][1]=2<br><br>arr[1][0]=3<br><br>arr[1][1]=4<br><br>当找寻arr[2][?]开头的二维数组时，一定走完了i<em>k个长度并且在a[i</em>k][0]的基础上在偏移k个数值即可找到二维数组的内存地址即<br><br>a[i][j]_address = base_address + (i*k+j)data_type_size</li></ul></blockquote></li></ul></blockquote><hr><h2 id="为何许多编程语言中数组下标从0开始？"><a href="#为何许多编程语言中数组下标从0开始？" class="headerlink" title="为何许多编程语言中数组下标从0开始？"></a>为何许多编程语言中数组下标从0开始？</h2><blockquote><ul><li>数组下标从数组内存模型来看，所谓的下标其实是以数组分配的连续内存空间首地址为参照的偏移量，a[0]代表的是该连续内存中，以内存地址首地址为参照，偏移0个位置。</li><li>历史原因 C语言设计者从0开始定义数组下标，java javascript 等 python支持负数下标</li></ul></blockquote><hr><h2 id="数组和链表的区别？"><a href="#数组和链表的区别？" class="headerlink" title="数组和链表的区别？"></a>数组和链表的区别？</h2><blockquote><ul><li>数组支持随机访问，根据下标随机访问的时间复杂度为O(1)</li></ul></blockquote><hr><h2 id="数组数据结构“插入”、“删除”低效的原因？"><a href="#数组数据结构“插入”、“删除”低效的原因？" class="headerlink" title="数组数据结构“插入”、“删除”低效的原因？"></a>数组数据结构“插入”、“删除”低效的原因？</h2><blockquote><ul><li>有序数组中插入元素的时间复杂度分析：<blockquote><ul><li>设数组长度为 n 将元素插入到数组k的位置，需要将k~N的位置往后移动</li><li>最好复杂度：插入到最后 O(1) 最坏复杂度：插入到最前面 O(n) <br><br>平均复杂度：插入到每个位置的概率为 $\frac{1}{n}$ 总共有1+2+…n 个元素 即  $\frac{1}{n}$*(1+2+…n) = $\frac{1}{n}$  *  $\frac{n + n² }{2}$ =  $\frac{n + 1 }{2}$ = O(n)</li></ul></blockquote></li><li>无序数组中插入元素的时间复杂度为 O(1)</li><li>有序数组中删除元素的时间复杂度分析：与插入一致<blockquote><ul><li>删除数据时，为防止出现多次搬运数据的情况，可先记录需要删除的元素，并一次进行删除。</li><li>JVM垃圾回收算法的 标记清除算法中 也有体现. 第一遍扫描先标记垃圾对象,第二遍扫描再清除垃圾对象. –&gt; 这种垃圾回收算法 容易产生内存碎片,导致出现虽然内存空间充足,但是无法放置大对象的诡异现象</li></ul></blockquote></li></ul></blockquote><hr><h2 id="数组越界问题"><a href="#数组越界问题" class="headerlink" title="数组越界问题"></a>数组越界问题</h2><h2 id="容器与数组"><a href="#容器与数组" class="headerlink" title="容器与数组"></a>容器与数组</h2><blockquote><ul><li>容器对于数组来讲是对数组数据结构的封装，并支持动态扩容。</li><li>可事先确定需要存储的数据大小，减少扩容操作涉及的内存申请和数据搬移。</li></ul></blockquote><h2 id="数组使用经验"><a href="#数组使用经验" class="headerlink" title="数组使用经验"></a>数组使用经验</h2><blockquote><ol><li>Java中的数组容器无法存储基本类型，如int、long，需要封装为Integer 自动拆装箱会带来一定的性能损耗，特别关注性能，或使用基本数据类型，可选用数组。</li><li>若数据大小确定，并且对数据操作简单。</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-复杂度分析</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2022-06-08T08:47:39.000Z</published>
    <updated>2022-06-09T08:38:28.184Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="笼统解释下什么是数据结构与算法"><a href="#笼统解释下什么是数据结构与算法" class="headerlink" title="笼统解释下什么是数据结构与算法"></a>笼统解释下什么是数据结构与算法</h2><blockquote><p>数据结构：一组数据存储的结构 <br><br>算法： 操作数据的一组方法<br>数据结构与算法无法分而治之的原因在于，数据结构为算法服务，算法需要作用于特定的数据结构上</p></blockquote><hr><h2 id="复杂度分析（衡量算法与代码执行效率的考量指标）"><a href="#复杂度分析（衡量算法与代码执行效率的考量指标）" class="headerlink" title="复杂度分析（衡量算法与代码执行效率的考量指标）"></a>复杂度分析（衡量算法与代码执行效率的考量指标）</h2><blockquote><ol><li>时间、控件复杂度分析方法（不依赖运行环境与测试数据，区别与事后统计法）</li></ol></blockquote><hr><h2 id="大O时间复杂度表示法-T-n-O-f-n"><a href="#大O时间复杂度表示法-T-n-O-f-n" class="headerlink" title="大O时间复杂度表示法  T(n) = O (f(n))"></a>大O时间复杂度表示法  T(n) = O (f(n))</h2><blockquote><p>推导过程 : 设代码执行时间为 T(n) 每行代码执行时间为 unit_time 为理想值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  int i = 1;</span><br><span class="line">  for (; i &lt;= n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  int i = 1;</span><br><span class="line">  int j = 1;</span><br><span class="line">  for (; i &lt;= n; ++i) &#123;</span><br><span class="line">    j = 1;</span><br><span class="line">    for (; j &lt;= n; ++j) &#123;</span><br><span class="line">      sum = sum +  i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>[第一段] 代码执行时间推导 第一、第二行执行时间为一个unit_time for循环中执行时间 第三、第四行都为n个unit_time 即为 2n*unit_time 总时长为   T(n) = (2+2n)*unit_time <br></li><li>[第二段] 代码执行时间推导 第一、第二、第三行执行时间为一个unit_time for循环中执行时间 第四、第五行都为n个unit_time 即为 2n* unit_time 第六、七执行时间为 n²* unit_time 总时长为   T(n) = (3+2n+2 ${n^2}$)*unit_time <br></li><li>结论 ： 代码执行时间T(n)与每行代码执行次数f(n)成正比即 T(n) = O (f(n))</li><li>公式解析 T(n)代码执行总时长 n 为数据规模 f(n)每行代码执行次数和 O表示执行时间T(n)与f(n)成正比</li><li>上述例子代入公式 T(n) = O (2+2n) T(n) = O (3+2n+2 ${n^2}$) </li><li>公式精简过程 ：当 n无限大时 低阶、常数、系数 不左右增加趋势，只需记录最大数量级，时间复杂度为 T(n)= O(n) ; T(n) = O(${n^2}$)</li></ul></blockquote><hr><h2 id="复杂度分析过程"><a href="#复杂度分析过程" class="headerlink" title="复杂度分析过程"></a>复杂度分析过程</h2><blockquote><ol><li>上述大O复杂度分析公式精简后，当n无限大时，时间复杂度分析方法中，只决定于数量级最大的部分，可忽略公式中的常数、系数、与低阶部分，只关注循环次数最多的一段代码。</li><li>加法法则 ： 总时间复杂度等于量级最大的代码时间复杂度</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">   int sum_1 = 0;</span><br><span class="line">   int p = 1;</span><br><span class="line">   for (; p &lt; 100; ++p) &#123;</span><br><span class="line">     sum_1 = sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   int sum_2 = 0;</span><br><span class="line">   int q = 1;</span><br><span class="line">   for (; q &lt; n; ++q) &#123;</span><br><span class="line">     sum_2 = sum_2 + q;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   int sum_3 = 0;</span><br><span class="line">   int i = 1;</span><br><span class="line">   int j = 1;</span><br><span class="line">   for (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = 1; </span><br><span class="line">     for (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum_3 = sum_3 +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   return sum_1 + sum_2 + sum_3;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>上述代码时间复杂度分为三段且忽略常数 第一段 忽略确定常数时间复杂度<br><br>第二段 O(n) 第三段忽略系数与低阶 O(${n^2}$) <br><br>加法法则得出这段代码时间复杂度为 T(n) = O(${n^2}$) <br><br>T1(n) = O(f(n)) T2(n) = O(g(n)) T(n) = T1(n)+T2(n) = Max(O(f(n)),O(g(n))) <br></li></ul><ol start="3"><li>乘法法则 ： 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">   int ret = 0; </span><br><span class="line">   int i = 1;</span><br><span class="line">   for (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret = ret + f(i);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> int f(int n) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  int i = 1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125; </span><br><span class="line">  return sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析乘法法则推导  T(n)= O(cal(n))* O(f(n)) = O(${n^2}$) <br><br>4. 当存在多个数据规模时，无法通过单一的加法与乘法法则进行相关复杂度判断<br>O(m+n) 、O(m*n)</p></blockquote><hr><h2 id="复杂度分析乘法法则推导-T-n-O-cal-n-O-f-n-O-n-2"><a href="#复杂度分析乘法法则推导-T-n-O-cal-n-O-f-n-O-n-2" class="headerlink" title="复杂度分析乘法法则推导  T(n)= O(cal(n))* O(f(n)) = O(${n^2}$)"></a>复杂度分析乘法法则推导  T(n)= O(cal(n))* O(f(n)) = O(${n^2}$)</h2><hr><h3 id="复杂度量级"><a href="#复杂度量级" class="headerlink" title="复杂度量级"></a>复杂度量级</h3><blockquote><ol><li>常量阶 O(1)<blockquote><ul><li>O(1)可表示下方代码时间复杂度</li></ul></blockquote></li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 8;</span><br><span class="line">int j = 6;</span><br><span class="line">int sum = i + j;</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>对数阶 O($\log{n}$)</li><li>线性对数阶 O(n $\log{n}$)<blockquote><ul><li>下方代码执行次数最多的是第三行，执行次数由n决定 i的值为等比数列值 <br></li><li>${2^1}$ ${2^2}$ ${2^3}$ ${2^4}$ ${2^x}$ = n 即 x = $\log{2^n}$ 与 $\log{3^n}$</li><li>对数阶时间复杂度可忽略底数标记为O($\log{n}$)推导如下<blockquote><ul><li>$\because$ $\log{3^n}$ = $\because$ $\log{3^2}$ * $\log{2^n}$ <br><br>又 $\because$  大O表示法忽略常数 <br><br>$\therefore$ T(n) = O(C*$\log{2^n}$) O(Cf(n))=O(f(n)) <br><br>$\therefore$ T(n) = O($\log{n}$)</li></ul></blockquote></li><li>线性对数阶在对数阶基础上循环执行n遍    </li></ul></blockquote></li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line"> i=1;</span><br><span class="line"> while (i &lt;= n)  &#123;</span><br><span class="line">   i = i * 2;</span><br><span class="line"> &#125;</span><br><span class="line">//2 </span><br><span class="line"> i=1;</span><br><span class="line"> while (i &lt;= n)  &#123;</span><br><span class="line">   i = i * 3;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>线性阶 O(n)</li><li>平方阶 O(${n^2}$) 、立方阶 O(${n^3}$) 、k次方阶 O(${n^k}$)</li><li>指数阶 O(${2^n}$) [非多项式量级]</li><li>阶乘阶段 O(n!) [非多项式量级]</li></ol></blockquote><h3 id="由低阶到高阶复杂度排序"><a href="#由低阶到高阶复杂度排序" class="headerlink" title="由低阶到高阶复杂度排序"></a>由低阶到高阶复杂度排序</h3><div style="text-align:center">    <img src="https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg" class="lazyload" data-srcset="https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="width:500px;"></div><hr><h2 id="时间复杂度与空间复杂度概述"><a href="#时间复杂度与空间复杂度概述" class="headerlink" title="时间复杂度与空间复杂度概述"></a>时间复杂度与空间复杂度概述</h2><h3 id="时间复杂度（渐进时间复杂度"><a href="#时间复杂度（渐进时间复杂度" class="headerlink" title="时间复杂度（渐进时间复杂度)"></a>时间复杂度（渐进时间复杂度)</h3><blockquote><ul><li>表示算法的执行时间与数据规模之间的增长关系</li></ul></blockquote><h3 id="空间复杂度（渐进空间复杂度"><a href="#空间复杂度（渐进空间复杂度" class="headerlink" title="空间复杂度（渐进空间复杂度)"></a>空间复杂度（渐进空间复杂度)</h3><blockquote><ul><li>表示算法的存储空间与数据规模之间的增长关系</li></ul></blockquote><hr><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><blockquote><ul><li>空间复杂度与代码中分配空间的代码有关，常见的空间复杂度量级为O(1)、O(n)、O(${n^2}$)</li></ul></blockquote><hr><h2 id="最好、最坏、平均、均摊-复杂度"><a href="#最好、最坏、平均、均摊-复杂度" class="headerlink" title="最好、最坏、平均、均摊 复杂度"></a>最好、最坏、平均、均摊 复杂度</h2><blockquote><ul><li>例程: 下方代码时间复杂度为O(n)</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// n表示数组array的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int pos = -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>例程: 下方代码因存在多种情况，时间复杂度无法按照现有的知识进行复杂度分析</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// n表示数组array的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int pos = -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>针对上述例程中存在的无法按照原有复杂度分析法进行分析会引入三种复杂度表示法<blockquote><ol><li>最好情况时间复杂度 ：最理想情况下执行这段代码复杂度 O(1)</li><li>最坏情况时间复杂度 ：最糟糕的情况下执行这段代码 O(n)</li><li>平均情况时间复杂度 ：加权平均时间复杂度/期望时间复杂度<blockquote><p>∵ 1+2+3+4+…..n 由等差数列公式得 $\frac{n²+n}{2}$<br><br>又∵ $\frac{n²+n}{2}$  + n = $\frac{n²+3n}{2}$  <br><br>∴$\frac{n²+3n}{2}$ / n+1 = $\frac{n²+3n}{2(n+1)}$ <br><br>∴大O表示法省略系数、低阶、常数 得 O(n)</p></blockquote></li><li>均摊时间复杂度 分析方法：摊还分析/平摊分析</li></ol></blockquote></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo简单搭建过程以及使用命令</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/07/Hexo%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/06/07/Hexo%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-06-07T08:31:54.000Z</published>
    <updated>2022-06-07T08:49:58.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><blockquote><ol><li>Node.js 安装完成后使用cmd执行 node -v 检查是否安装成功</li><li>下载cnpm 淘宝镜像源 npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> 查看版本 cnpm -v</li><li>使用淘宝镜像源下载 hexo博客  cnpm install -g hexo-cli </li><li>查看hexo版本  hexo -v</li></ol></blockquote><hr><h2 id="创建空文件夹用于存放博客内容"><a href="#创建空文件夹用于存放博客内容" class="headerlink" title="创建空文件夹用于存放博客内容"></a>创建空文件夹用于存放博客内容</h2><blockquote><ol><li>hexo init  windows下使用命令</li><li>启动hexo服务 hexo s</li><li>新建博客 hexo n “名称”</li><li>重新生成博客 hexo clean  hexo g </li><li>下载用于推送到git的插件 cnpm install –save hexo-deployer-git</li><li>hexo d 推送到远端</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Hexo博客" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo博客" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Java中的静态变量</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/28/Java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/28/Java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</id>
    <published>2022-05-28T08:13:49.000Z</published>
    <updated>2022-06-07T09:59:36.760Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java中的静态变量"><a href="#Java中的静态变量" class="headerlink" title="Java中的静态变量"></a>Java中的静态变量</h2><blockquote><ul><li>Java中的静态变量也叫作类变量,被关键字static修饰 </li><li>静态变量可以不被赋值，java会分配一个初始值</li><li>静态变量命名规范：一般使用全字母大写与下划线进行分割</li><li>静态变量不会随着变量的创建而创建，属于类</li></ul></blockquote><h2 id="Java中的静态方法"><a href="#Java中的静态方法" class="headerlink" title="Java中的静态方法"></a>Java中的静态方法</h2><blockquote><ul><li>类方法，无this自引用使用，可操作形参与静态变量（自身的静态变量或者其他类的静态变量）</li></ul></blockquote><h2 id="Java中的静态方法的重载"><a href="#Java中的静态方法的重载" class="headerlink" title="Java中的静态方法的重载"></a>Java中的静态方法的重载</h2><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JAVA基础" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JAVA基础" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>动态代理是基于什么原理？</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/26/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/26/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/</id>
    <published>2022-05-26T07:41:02.000Z</published>
    <updated>2022-06-07T10:08:17.698Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="动态代理是基于什么原理？"><a href="#动态代理是基于什么原理？" class="headerlink" title="动态代理是基于什么原理？"></a>动态代理是基于什么原理？</h2><blockquote><p>从编程语言分类角度来讲，按照语言类型信息是在运行时检查，还是编译期检查分为动态类型和静态类型的编程语言 <br><br>不同类型变量赋值时，是否需要显示地（强制）进行类型转换可区分是否是所谓的强类型或弱类型语言。<br><br>Java语言是静态的强类型语言，但因为反射的存在，也具备部分动态语言的能力。</p></blockquote><h2 id="Java中的反射机制"><a href="#Java中的反射机制" class="headerlink" title="Java中的反射机制"></a>Java中的反射机制</h2><blockquote><p>反射机制是Java语言提供的一种基础功能，赋予程序在运行时的自省能力，通过反射我们可以直接操作类，或者对象，获取类的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p></blockquote><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><blockquote><p>运行时动态构建代理、动态处理代理方法调用的机制【包装RPC调用、AOP（面向切面编程）】</p></blockquote><h3 id="实现动态代理的方式"><a href="#实现动态代理的方式" class="headerlink" title="实现动态代理的方式"></a>实现动态代理的方式</h3><blockquote><p>JDK中主要利用反射机制、其他实现方式如：传说中更高性能的字节码操作机制、类似ASM、cglib、JavaSsist</p></blockquote><h3 id="AccessibleObject-setAccessible​"><a href="#AccessibleObject-setAccessible​" class="headerlink" title="AccessibleObject.setAccessible​"></a>AccessibleObject.setAccessible​</h3><blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AccessibleObject.setAccessible​(<span class="type">boolean</span> flag)   </span><br></pre></td></tr></table></figure><blockquote><ul><li>反射中需要显示更改setAccessible的值进行私有属性的获取、或者方法的获取，需要设置为true</li><li>O/R Mapping 框架中，为一个Java实体对象，运行时自动生成setter、getter逻辑</li><li>绕过API访问控制</li></ul></blockquote><blockquote><p>Java9以后，出于强封装性的考虑，对反射访问进行了限制，Jigsaw引入了Open的概念，只有当被反射操作的模块和指定的包对反射调用者模块Open，才能使用setAccessible</p></blockquote><h2 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h2><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JAVA基础面试题" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="JAVA基础面试题" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuilder、StringBuffer有什么区别</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/26/String%E3%80%81StringBuilder%E3%80%81StringBuffer%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/26/String%E3%80%81StringBuilder%E3%80%81StringBuffer%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</id>
    <published>2022-05-26T07:38:12.000Z</published>
    <updated>2022-06-07T10:08:28.007Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="String、StringBuilder、StringBuffer有什么区别"><a href="#String、StringBuilder、StringBuffer有什么区别" class="headerlink" title="String、StringBuilder、StringBuffer有什么区别"></a>String、StringBuilder、StringBuffer有什么区别</h2><blockquote><p>Java每日一记1 内容更改 <br><br>Java8中新增的StringJoiner工具类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringJoiner</span> <span class="variable">stringjoiner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;分割符&quot;</span>);</span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">stringjoiner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;分割符&quot;</span>,<span class="string">&quot;前缀delimiter&quot;</span>,<span class="string">&quot;后缀suffix&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><ol><li>String 类在java中是典型的immutable类 类被声明为final,属性也被final修饰，由于不可变性，对于字符串拼接、裁剪等动作时，都会产生新的String对象。</li><li>StringBuffer 为解决上述拼接中产生太多对象问题而提供的类，本质上是一个线程安全的可修改字符序列</li><li>StringBuilder 在能力上与StringBuffer没有本质区别，但去掉了线程安全的部分。</li></ol></blockquote><blockquote><ul><li>String 是典型的immutable类的典型实现，原生保证了线程安全<blockquote><ul><li>(1) String的创建机理 <br><br>由于String在Java世界中使用过于频繁，Java为了避免在一个系统中产生大量的String对象，引入了字符串常量池。其运行机制是：创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建直接从池中刚查找到的对象引用；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。</li></ul></blockquote></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>; <span class="comment">//通过直接量赋值方式，放入字符串常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(“<span class="number">123</span>”);<span class="comment">//通过new方式赋值方式，不放入字符串常量池</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><ul><li>注意：String提供了inter()方法。调用该方法时，如果常量池中包括了一个等于此String对象的字符串（由equals方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并且返回此池中对象的引用。</li><li>(2) String的特性 <br><br>[A] 不可变。是指String对象一旦生成，则不能再对它进行改变。不可变的主要作用在于当一个对象需要被多线程共享，并且访问频繁时，可以省略同步和锁等待的时间，从而大幅度提高系统性能。不可变模式是一个可以提高多线程程序的性能，降低多线程程序复杂度的设计模式。<br><br>[B] 针对常量池的优化。当2个String对象拥有相同的值时，他们只引用常量池中的同一个拷贝。当同一个字符串反复出现时，这个技术可以大幅度节省内存空间。</li></ul></blockquote><ul><li>StringBuffer 的线程安全是通过把各种修改数据的方法都加上了synchronized关键字实现的</li><li>StringBuffer与StringBuilder底层都是利用可修改的char数组（java9以后是byte数组）区别是最终方法是否加了synchronized</li></ul></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JAVA基础面试题" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="JAVA基础面试题" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>强引用、软引用、弱引用、幻象引用有什么区别?</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/26/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/26/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</id>
    <published>2022-05-26T01:53:15.000Z</published>
    <updated>2022-06-07T10:08:11.258Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="强引用、软引用、弱引用、幻象引用有什么区别"><a href="#强引用、软引用、弱引用、幻象引用有什么区别" class="headerlink" title="强引用、软引用、弱引用、幻象引用有什么区别"></a>强引用、软引用、弱引用、幻象引用有什么区别</h2><blockquote><p>Java中将除基本数据类型意外的各类对象的对象引用，按其生命周期的长短，将其分为四类</p></blockquote><h3 id="各种引用"><a href="#各种引用" class="headerlink" title="各种引用"></a>各种引用</h3><blockquote><p>不同引用类型体现的是对象不同的可达性和对垃圾收集的影响 <br></p><ol><li>强引用 （Strong reference）<blockquote><ol><li>即普通的对象引用，存在强引用指向的对象，垃圾收集器不会碰这种对象</li><li>通过new 关键字创建的对象所关联的引用就是强引用，当JVM内存空间不足时，JVM宁愿抛出OutOfMemoryError运行时错误，也不随意回收强引用对象。</li><li>普通对象，如果没有其他引用关系，只要超过了引用的作用域或显式将强引用赋值为null，就是可以被垃圾收集。</li></ol></blockquote></li><li>软引用 （SoftReference）<blockquote><ul><li> 相对于强引用来讲弱化一点的引用,当JVM认为内存不足时，才会去试图回收软引用对象，JVM会确保在抛出OutOfMemoryError之前，清理软引用指向对象。</li><li>一般应用于实现内存敏感的缓存</li></ul></blockquote></li><li>弱引用 （WeakReference）<blockquote><ul><li>提供一种访问在弱引用状态下对象的途径 ，不管当前内存空间是否足够，都会回收它的内存</li></ul></blockquote></li><li>幻象引用（虚引用）（PhantomReference）<blockquote><ul><li>无法通过该引用获取对象，仅仅提供一种确保对象被finalize以后，做某些事情的机制</li></ul></blockquote></li></ol></blockquote><h3 id="引用队列-ReferenceQueue"><a href="#引用队列-ReferenceQueue" class="headerlink" title="引用队列 ReferenceQueue"></a>引用队列 ReferenceQueue</h3><blockquote><p>我们在创建各种引用并关联到相应对象时，可选择是否需要关联引用队列，JVM会在特定时机将引用enqueue到队列中，我们可以从队列里获取引用并进行相关后续逻辑。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">refQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; p = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(counter, refQueue);</span><br><span class="line">counter = <span class="literal">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Remove是一个阻塞方法，可以指定timeout，或者选择一直阻塞</span></span><br><span class="line">    Reference&lt;Object&gt; ref = refQueue.remove(<span class="number">1000L</span>);</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// Handle it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>软引用，弱引用可与引用队列联合使用，当相应引用的对象被垃圾回收器回收，JVM会把软引用加入到关联的引用队列中。 <br><br>虚引用必须要与引用队列联合使用，程序可通过判断引用队列中师傅已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收，若已被加入到队列，name可在被引用的对象在内存回收之前采取一些程序行动。</p></blockquote><hr><h3 id="对象声明周期与不同可达性状态"><a href="#对象声明周期与不同可达性状态" class="headerlink" title="对象声明周期与不同可达性状态"></a>对象声明周期与不同可达性状态</h3><blockquote><ul><li>强可达 （Strongly Reachable）<blockquote><ul><li>当一个对象可以有一个或多个线程不通过各种引用访问到的情况（新创建一个对象，那么创建它的线程对它就是强可达）</li></ul></blockquote></li><li>软可达 (Softly Reachable)<blockquote><ul><li>只能通过软引用才能访问到对象的状态</li></ul></blockquote></li><li>弱可达 (Weakly Reachable)<blockquote><ul><li>无法通过强引用或软引用访问，只能通过弱引用访问时的状态</li></ul></blockquote></li><li>幻象可达 (Phantom Reachable)<blockquote><ul><li>没有强、软、弱引用关联，并且finalize过了，只有幻象引用指向这个对象</li></ul></blockquote></li><li>不可达 (unreachable)<blockquote><ul><li>对象被清除</li></ul></blockquote></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JAVA基础面试题" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="JAVA基础面试题" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>final finally finalize 有何不同?</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/26/final-finally-finalize-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/26/final-finally-finalize-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/</id>
    <published>2022-05-26T01:52:12.000Z</published>
    <updated>2022-06-07T10:08:54.781Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="final-finally-finalize-有何不同"><a href="#final-finally-finalize-有何不同" class="headerlink" title="final finally finalize 有何不同"></a>final finally finalize 有何不同</h2><hr><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><blockquote><ul><li>final修饰符可修饰类、方法、变量</li><li>类无法被继承、方法不可被重写、变量不可被修改</li><li>final关键字经常大量出现在源码或第三方类库中，可有效避免API使用者更改基础功能，在并发编程中有利于减少额外的同步开销。</li><li>final只可约束相关变量引用不可以被赋值，但final修饰的对象行为不会被final影响</li></ul></blockquote><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><blockquote><ul><li>保证重点代码一定被执行的一种机制</li><li>以下代码finally不会被执行</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    System.exit(<span class="number">1</span>);      </span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;print from finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><blockquote><p>保证对象在被垃圾收集前完成特定资源的回收，java9开始被标记为deprecated（不赞成）</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JAVA基础面试题" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="JAVA基础面试题" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java 中的 Exception 与 Error</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/26/java-%E4%B8%AD%E7%9A%84-Exception-%E4%B8%8E-Error/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/26/java-%E4%B8%AD%E7%9A%84-Exception-%E4%B8%8E-Error/</id>
    <published>2022-05-26T01:48:55.000Z</published>
    <updated>2022-06-07T10:08:40.757Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Exception-Error区别"><a href="#Exception-Error区别" class="headerlink" title="Exception Error区别"></a>Exception Error区别</h2><hr><h3 id="Java中的Throwable-Exception-Error设计与分类"><a href="#Java中的Throwable-Exception-Error设计与分类" class="headerlink" title="Java中的Throwable Exception Error设计与分类"></a>Java中的Throwable Exception Error设计与分类</h3><blockquote><p>典型回答：Exception 与 Error都继承了Throwable类，在Java中只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch）<br><br>Exception是程序正常运行中可预料的意外情况，可能并应当进行捕获。<br></p><blockquote><p>checked （可检查异常）：编译期的一部分<br><br>unchecked （不可检查异常）：运行时异常类似NullPointerException 可通过相关逻辑进行避免<br><br>Error 是程序处于非正常、不可恢复状态，所以不便进行捕获。</p></blockquote></blockquote><hr><h3 id="常见Exception-与-Error"><a href="#常见Exception-与-Error" class="headerlink" title="常见Exception 与 Error"></a>常见Exception 与 Error</h3><blockquote><p>Exception (checked Exception)</p><blockquote><ol><li>IOException </li></ol></blockquote></blockquote><blockquote><p>Exception (RuntimeException)</p><blockquote><ol><li>NullPointerException （空指针）</li><li>ClassCastException（类型转换异常）</li><li>SecurityException （）</li><li>ArrayIndexOutofBoundsException</li></ol></blockquote></blockquote><blockquote><p>Error (虚拟机错误：VirtualMachineError) </p><blockquote><ol><li>OutOfMemoryError （内存溢出错误）</li><li>StackOverflowError （堆栈溢出错误）</li></ol></blockquote></blockquote><blockquote><p>Error (链接错误 LinkageError) </p><blockquote><ol><li>NoClassDefFoundError </li><li>UnsatisfiedLinkError</li><li>ExceptionInIInitiallizerError</li></ol></blockquote></blockquote><hr><h3 id="面试题-NoClassDefFoundError-与-ClassNotFoundException"><a href="#面试题-NoClassDefFoundError-与-ClassNotFoundException" class="headerlink" title="面试题 NoClassDefFoundError 与 ClassNotFoundException"></a>面试题 NoClassDefFoundError 与 ClassNotFoundException</h3><blockquote><p>一个Error一个Exception <br><br>ClassNotFoundException 是在java中显示类加载时（编译过程中）产生的，产生原因如下</p><blockquote><ol><li>Class.forName()</li><li>ClassLoader中的findSystemClass()</li><li>ClassLoader中的loadClass()<br></li></ol></blockquote></blockquote><blockquote><p>NoClassDefFoundError <br><br>错误发生的原因是因为Java虚拟机在编译期间可找到合适的类，但在运行时找不到合适的类</p></blockquote><h3 id="异常处理原则"><a href="#异常处理原则" class="headerlink" title="异常处理原则"></a>异常处理原则</h3><blockquote><ol><li>尽可能不要捕获泛泛Exception,代码中存在的具体可确定异常类型需要进行具体类型的捕获。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>生吞异常,无日志输出</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JAVA基础面试题" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="JAVA基础面试题" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM-03-java虚拟机如何加载class类</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/19/JVM-03-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDclass%E7%B1%BB/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/19/JVM-03-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDclass%E7%B1%BB/</id>
    <published>2022-05-19T09:32:15.000Z</published>
    <updated>2022-05-20T01:31:00.036Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java中的基本数据类型"><a href="#Java中的基本数据类型" class="headerlink" title="Java中的基本数据类型"></a>Java中的基本数据类型</h1><blockquote><p>为什么在谈论Java虚拟机时如何加载class类时会优先谈关于Java的数据类型的话题？</p><blockquote><p>在java中除去基本数据类型还存在引用数据类型，但基本数据类型已经由Java虚拟机预先定义完成，刨除基本数据类型后，存在的引用数据类型分为以下四类</p><blockquote><ul><li>类</li><li>接口</li><li>数组</li><li>泛型参数<br>真正经由jvm进行加载的引用类型只有类、与接口两类，并且都有对应的字节流。而jvm类加载过程，实际上是查找对应字节流，并将其加载到内存中调用的过程。</li></ul></blockquote></blockquote></blockquote><hr><h1 id="Java中的类主要加载过程"><a href="#Java中的类主要加载过程" class="headerlink" title="Java中的类主要加载过程"></a>Java中的类主要加载过程</h1><blockquote><p>类的加载过程主要有 <br></p><ul><li>加载 :  jvm虚拟机借助类加载器查找类字节流文件并创建的过程</li><li>链接 :  将创建完成的类合并到虚拟机中使类可以执行的过程<blockquote><ul><li>验证 ：确保加载的类满足java虚拟机约束规范</li><li>准备 ：为被加载类的静态字段分配内存,部分java虚拟机会生构造与其他类层次相关的数据结构</li><li>解析 ：将符号引用解析为实际引用</li></ul></blockquote></li><li>初始化 ：为标记为常量值的字段赋值，以及执行<code>&lt;clinit&gt;</code>的过程</li></ul></blockquote><hr><h1 id="Java中的类加载过程-加载-jvm中的类加载器"><a href="#Java中的类加载过程-加载-jvm中的类加载器" class="headerlink" title="Java中的类加载过程 - 加载 jvm中的类加载器"></a>Java中的类加载过程 - 加载 jvm中的类加载器</h1><blockquote><ul><li>启动类加载器 【bootstrap class loader】<br><br>启动类加载器由C++ 编写，在java中无对应对象</li><li>扩展类加载器 【extension class Loader】 （父类为启动类加载器）<br></li><li>应用类加载器 【application class loader】（父类扩展类加载器）<br></li></ul></blockquote><hr><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><blockquote><p>当类加载器接到加载java类加载请求后，当前类加载器会首先将请求转发给其父类的类加载器，父类的类加载器会尝试进行类的查找，当无法找到对应类的字节流后会将请求重新发送给当前类加载器，并尝试进行类字节流信息的查找。</p></blockquote><hr><h3 id="java9之前各种类加载器加载的内容"><a href="#java9之前各种类加载器加载的内容" class="headerlink" title="java9之前各种类加载器加载的内容"></a>java9之前各种类加载器加载的内容</h3><blockquote><ul><li>启动类加载器 : jre lib目录下jar包中的类 以及由虚拟机参数 -Xbootclasspath指定的类</li><li>扩展类加载器 : jre lib ext目录下jar包中的类 以及系统变量 java.ext.dirs指定的类</li><li>应用类加载器 : 负责加载应用程序路径（虚拟机参数 -cp/-classpath、系统变量java.class.path或环境变量classpath所指定的路径）下的类<br></li></ul></blockquote><hr><h3 id="java9模块系统"><a href="#java9模块系统" class="headerlink" title="java9模块系统"></a>java9模块系统</h3><blockquote><p>扩展类加载器更名为平台类加载器 除javase中几个关键模块 (javabase)其他均由平台加载器加载</p></blockquote><hr><h1 id="Java中的类加载过程-链接"><a href="#Java中的类加载过程-链接" class="headerlink" title="Java中的类加载过程 - 链接"></a>Java中的类加载过程 - 链接</h1><blockquote><ul><li>链接-准备过程中当引用此类本身的方法，属性或引用其他方法、字段时，Java编译器会生成一个符号引用。</li><li>链接-解析、解析过程中当符号引用指向一个未被加载的类、或者未被加载类的字段或方法时，解析将触发这个类的加载（未必触发这个类的链接以及初始化）</li></ul></blockquote><hr><h1 id="Java中的类加载过程-初始化"><a href="#Java中的类加载过程-初始化" class="headerlink" title="Java中的类加载过程 - 初始化"></a>Java中的类加载过程 - 初始化</h1><blockquote><p><code>ConstantValue 常量值</code> <br><br>在Java代码中，如果在初始化一个静态字段时直接对其声明、赋值，并且该静态字段被final修饰，数据类型为基本数据类型或字符串时，Java编译器会将其标记为常量值，初始化直接由虚拟机完成。<br><br><code>&lt;clinit&gt;</code> <br><br>除上述之外的直接赋值操作，以及所有静态代码块中的代码，会被java编译器置于同一方法中，并被命名为<code>&lt;clinit&gt;</code><br><br>类初始化完成后，才会成为可执行状态。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JVM" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java中的注解与反射</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/15/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/15/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</id>
    <published>2022-05-15T12:35:40.000Z</published>
    <updated>2022-06-07T09:59:32.593Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解 Annotation"></a>注解 Annotation</h2><blockquote><ul><li>基本格式： @ 注释名</li><li>使用位置： package class method filed上</li></ul></blockquote><h3 id="内置注解-Java本身自带的注解"><a href="#内置注解-Java本身自带的注解" class="headerlink" title="内置注解(Java本身自带的注解)"></a>内置注解(Java本身自带的注解)</h3><blockquote><ul><li>@Override 重写 不做解释</li><li>@Deprecated 不鼓励使用这样的元素</li><li>@SuppressWarnings 镇压警告信息 可传参</li></ul></blockquote><h3 id="元注解-解释其他注解的注解"><a href="#元注解-解释其他注解的注解" class="headerlink" title="元注解 解释其他注解的注解"></a>元注解 解释其他注解的注解</h3><blockquote><ul><li>@Target 描述注解使用范围</li><li>@Retention Source &lt; Class &lt; Runtime</li><li>@Document 注解将被包含在javadoc中</li><li>@Inherited 子类可继承父类中的该注解</li></ul></blockquote><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><blockquote><ul><li>自定义注解格式 修饰符 @interface 注解名{定义内容}</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CeshiAnnotation&#123;</span><br><span class="line">    <span class="comment">//参数类型 参数名 ps:自定义注解的格式跟接口中的方法定义类似但实际意义不同</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射-reflection"><a href="#反射-reflection" class="headerlink" title="反射 reflection"></a>反射 reflection</h2><h3 id="Java中的反射机制"><a href="#Java中的反射机制" class="headerlink" title="Java中的反射机制"></a>Java中的反射机制</h3><blockquote><ul><li>增加了Java语言的动态机制，反射机制允许程序执行期间借助Reflection API获取类的内部信息</li><li>java语言中，反射机制的出现使得class文件在程序执行过程中也可获取类的全部信息</li><li>反射精髓在于“反”字，可通过对象反推获取相关类信息</li></ul></blockquote><h3 id="Java中获取Class对象实例的方式"><a href="#Java中获取Class对象实例的方式" class="headerlink" title="Java中获取Class对象实例的方式"></a>Java中获取Class对象实例的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Class&lt;?&gt; c1 = Person.class;</span><br><span class="line">    System.out.pringln(c1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    Class&lt;?&gt; c1 = person.getClass();</span><br><span class="line">    System.out.pringln(c1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Class&lt;?&gt; c1 = Class.forName(<span class="string">&quot;类名路径&quot;</span>);</span><br><span class="line">    System.out.pringln(c1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法只对Java基本数据类型的包装类有效</span></span><br><span class="line">Class&lt;?&gt; c1 = Integer.TYPE;</span><br></pre></td></tr></table></figure><h2 id="哪些类型可以有Class类"><a href="#哪些类型可以有Class类" class="headerlink" title="哪些类型可以有Class类"></a>哪些类型可以有Class类</h2><blockquote><ul><li>java中的对象基本都可以获取到class类型，例如 内部类、接口、数组、枚举、注解、基本数据类型、void</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JAVA基础" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JAVA基础" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>GIT知识</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/08/GIT%E7%9F%A5%E8%AF%86/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/05/08/GIT%E7%9F%A5%E8%AF%86/</id>
    <published>2022-05-08T02:31:12.000Z</published>
    <updated>2022-05-14T02:41:15.070Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="git目录文件"><a href="#git目录文件" class="headerlink" title=".git目录文件"></a>.git目录文件</h2><blockquote><ul><li>HEAD文件<blockquote><p> 存放当前Git工作指向分支 ：ref: refs/heads/master 切换路径后会发生变化</p></blockquote></li><li>config文件 <blockquote><p>本地仓库配置信息，会设置在config文件中</p></blockquote></li><li>refs文件 <blockquote><ul><li>1 heads 分支 heads分支文件中会存在多个文件，每个文件中存放的类似指针，会指向相应commit </li><li>2 tags 里程碑</li></ul></blockquote></li><li>objects 存放对象 </li></ul></blockquote><h2 id="git对象之间的关系-commit-tree-blob"><a href="#git对象之间的关系-commit-tree-blob" class="headerlink" title="git对象之间的关系 commit tree blob"></a>git对象之间的关系 commit tree blob</h2><blockquote><ul><li>commit 每次变更后会产生一个commit对象 一个commit对应一棵树 tree</li><li>tree 视图 当前commit对应项目此时全部的文件快照 (文件夹)</li><li>blob 文件 文件内容相同git中只有一份 与文件名无关</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Git 基础" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/Git-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Git 基础" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/Git-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>GIT基础命令</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/04/30/GIT%E5%9F%BA%E7%A1%80/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/04/30/GIT%E5%9F%BA%E7%A1%80/</id>
    <published>2022-04-30T12:07:45.000Z</published>
    <updated>2022-05-08T03:22:00.062Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Windows中的cmd命令"><a href="#Windows中的cmd命令" class="headerlink" title="Windows中的cmd命令"></a>Windows中的cmd命令</h2><blockquote><ul><li>cls 清屏</li></ul></blockquote><h2 id="GIT基础命令"><a href="#GIT基础命令" class="headerlink" title="GIT基础命令"></a>GIT基础命令</h2><blockquote><ul><li> git config –global/local/system 设置命令除了作用域不一致其他都相同</li><li>1 git –verison 查看GT版本</li><li>2 git config –global –list 查看git用户信息</li><li>3 git config –global user.name ‘your_name’</li><li>4 git config –global user.email ‘your_email@邮箱地址’</li></ul></blockquote><h2 id="GIT-命令-config-命令"><a href="#GIT-命令-config-命令" class="headerlink" title="GIT 命令 config 命令"></a>GIT 命令 config 命令</h2><h4 id="local参数设置优先级高于global"><a href="#local参数设置优先级高于global" class="headerlink" title="local参数设置优先级高于global"></a>local参数设置优先级高于global</h4><blockquote><ul><li>1 git config –local  local只对某个仓库有效<blockquote><ul><li>1 git config –local user.name 查看当前仓库配置的用户名</li><li>2 git config –local user.name ‘需要设置的用户名’ 修改配置信息用户名</li></ul></blockquote></li><li>2 git config –global global对当前用户下所有仓库有效</li><li>3 git config –system system对系统所有登录的用户有效</li></ul></blockquote><h2 id="显示-config-配置"><a href="#显示-config-配置" class="headerlink" title="显示 config 配置"></a>显示 config 配置</h2><blockquote><ul><li>1 git config –list –local</li><li>2 git config –list –global</li><li>3 git config –list –system </li></ul></blockquote><h2 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h2><blockquote><p>新建项目直接使用Git管理</p><ul><li>1 进入新项目目标文件夹</li><li>2 git init project_name </li></ul></blockquote><h2 id="使用Git新增并提交文件"><a href="#使用Git新增并提交文件" class="headerlink" title="使用Git新增并提交文件"></a>使用Git新增并提交文件</h2><blockquote><ul><li>1 git add 文件名 管控需要新增的文件</li><li>2 git commit -m ‘新增理由’  提交新增的文件</li><li>3 git status git状态 </li></ul></blockquote><h2 id="使用Git对修改的文件提交到暂存区"><a href="#使用Git对修改的文件提交到暂存区" class="headerlink" title="使用Git对修改的文件提交到暂存区"></a>使用Git对修改的文件提交到暂存区</h2><blockquote><ul><li>1 git add -u 被git管控的文件提交到暂存区 -u update</li></ul></blockquote><h2 id="Git-对文件重命名操作"><a href="#Git-对文件重命名操作" class="headerlink" title="Git 对文件重命名操作"></a>Git 对文件重命名操作</h2><blockquote><ul><li>1 Git新增重命名文件并删除原名称文件<blockquote><ul><li>1 git rm 文件名称  </li><li>2 git add 新文件名称 </li><li>3 git commit -m “”</li></ul></blockquote></li><li>2 Git一条命令替换上面三条<blockquote><ul><li>1  git mv 旧文件名 新文件名</li></ul></blockquote></li></ul></blockquote><h2 id="查看Git日志或版本历史-git-log-命令"><a href="#查看Git日志或版本历史-git-log-命令" class="headerlink" title="查看Git日志或版本历史 git log 命令"></a>查看Git日志或版本历史 git log 命令</h2><p>图形化查看 –graph </p><blockquote><ul><li>1 git log –oneline 简短历史</li><li>2 git log -n条数 –oneline 设置选择查看条数的简短历史</li><li>3 git log –oneline –all 查看全部分支的历史</li><li>4 git log –oneline –all -n条数  查看全部分支的历史的某几条</li></ul></blockquote><h2 id="Git-分支操作"><a href="#Git-分支操作" class="headerlink" title="Git 分支操作"></a>Git 分支操作</h2><blockquote><ul><li>1 git branch -v 查看本地git有多少分支</li><li>2 git checkout 分支名称 切换分支</li></ul></blockquote><h2 id="Git暂存区"><a href="#Git暂存区" class="headerlink" title="Git暂存区"></a>Git暂存区</h2><blockquote><ul><li>Git暂存区中的文件可以记录文件每次变更的地方</li></ul></blockquote><h2 id="Git-通过文件Hash数值查看文件类型和内容"><a href="#Git-通过文件Hash数值查看文件类型和内容" class="headerlink" title="Git 通过文件Hash数值查看文件类型和内容"></a>Git 通过文件Hash数值查看文件类型和内容</h2><blockquote><ul><li>git cat-file -t hash值 类型</li><li>git cat-file -p hash值 内容</li></ul></blockquote><h2 id="Git-web版帮助文档查看"><a href="#Git-web版帮助文档查看" class="headerlink" title="Git web版帮助文档查看"></a>Git web版帮助文档查看</h2><p>git help –web 命令 ps: git help –web log</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Git 基础" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/Git-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Git 基础" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/Git-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JVM-01-java代码是如何运行的</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/04/27/JVM-01-java%E4%BB%A3%E7%A0%81%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/04/27/JVM-01-java%E4%BB%A3%E7%A0%81%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/</id>
    <published>2022-04-27T07:51:04.000Z</published>
    <updated>2022-05-19T09:32:20.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>01 | JAVA中的JVM是如何识别运行高级语言所编写的代码的？</p><hr><p>三个问题</p><blockquote><ul><li><ol><li>我们对于JAVA所宣传的“一次编译，到处运行”是怎样理解的呢？</li></ol></li><li><ol start="2"><li>JAVA作为一门高度抽象的语言，在经过成熟的IDE编写后，那些能被我们所看懂的代码，到底是如何在JVM中运行的呢？</li></ol></li><li><ol start="3"><li>JAVA语言到底是编译执行还是解释执行？</li></ol></li></ul></blockquote><hr><h3 id="Write-once-run-anywhere"><a href="#Write-once-run-anywhere" class="headerlink" title="Write once, run anywhere"></a>Write once, run anywhere</h3><blockquote><p>我们在学习JVM的时候，绕不过去的是JAVA中关于JRE（Java Runtime Environment ）与JDK(Java Development Kit )的定义<strong>JVM</strong>位于JRE中 JDK又包含JRE,（Write once, run anywhere）纠其实现原因也绕不JVM,不同于C++，(C++可将编写完成的代码直接编译成机器码)Java代码经过程序员（人类）的编写后，产生的代码计算机并不能看懂，Java通过javac命令的编译后，会将由人类可以看懂的程序指令编译为JVM虚拟机可以看懂的 <strong>.class</strong> 结尾的字节码文件，再由JVM虚拟机将其翻译成计算机可以看懂的 <strong>机器码</strong>，并最终执行。JVM可以将程序员所编写的代码部署到不同系统的计算机上，整个过程，开发人员只需要编写一次代码，并将.class文件交给不同系统中的JVM即可，充分与硬件环境之间进行解耦操作。</p></blockquote><hr><h3 id="JVM虚拟机中是如何运行字节码文件的？"><a href="#JVM虚拟机中是如何运行字节码文件的？" class="headerlink" title="JVM虚拟机中是如何运行字节码文件的？"></a>JVM虚拟机中是如何运行字节码文件的？</h3><blockquote><p><em><strong>摘自极客时间《深入拆解JAVA虚拟机 》</strong></em> <br/><br>在主流Java版本中以HotSpot虚拟机为例，JVM虚拟机在接收到class字节码文件后，首先通过类加载器（Class-Loader）加载字节码文件，（ps:省略具体加载过程）加载后的Java类会被存放于方法区，代码运行过程中会JVM会执行方法区中的代码。<br/><br> JVM在运行Java代码时，会在计算机内存中划分栈与堆来存储数据，在栈中会分为面向Java方法的Java方法栈，本地方法的本地方法栈，以及存放各个线程执行位置的PC寄存器</p></blockquote><div align=center><img src="https://static001.geekbang.org/resource/image/ab/77/ab5c3523af08e0bf2f689c1d6033ef77.png#pic_center" class="lazyload" data-srcset="https://static001.geekbang.org/resource/image/ab/77/ab5c3523af08e0bf2f689c1d6033ef77.png#pic_center" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="400"></div><br/><h3 id="JVM虚拟机如何将字节码文件翻译为机器码？"><a href="#JVM虚拟机如何将字节码文件翻译为机器码？" class="headerlink" title="JVM虚拟机如何将字节码文件翻译为机器码？"></a>JVM虚拟机如何将字节码文件翻译为机器码？</h3><blockquote><p>在HotSpot虚拟机中，翻译为机器码的过程有两种形式</p><blockquote><ul><li>解释执行 ：将字节码逐条翻译并执行</li><li>即使编译（JUST-In-Time compilation JIT） ： 将字节码全部编译完成机器码后执行</li></ul></blockquote></blockquote><div align=center><img src="https://static001.geekbang.org/resource/image/5e/3b/5ee351091464de78eed75438b6f9183b.png#pic_center" class="lazyload" data-srcset="https://static001.geekbang.org/resource/image/5e/3b/5ee351091464de78eed75438b6f9183b.png#pic_center" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="400"></div><br/><blockquote><p>HotSpot默认采用混合模式（-Xmixed）进行编译,通过内置的两个不同的JIT compiler 即 C1  C2 以及 Graal jaotc工具等 内置多个编译器是为了可让用户针对不同的需求进行相应的取舍，C1 为Client 模式，适用于对启动速度敏感的应用，C2对应Server模式，除了常见的Java使用模式外，还有一种新的编译方式，即所谓的AOT(Ahead-of-Time Compilation),直接将字节码编译成机器码。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JVM" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java每日一记</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/04/07/Java%E6%AF%8F%E6%97%A5%E7%96%91%E6%83%91/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2022/04/07/Java%E6%AF%8F%E6%97%A5%E7%96%91%E6%83%91/</id>
    <published>2022-04-07T12:42:18.000Z</published>
    <updated>2022-06-07T09:59:28.267Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Java8中新增的StringJoiner工具类"><a href="#Java8中新增的StringJoiner工具类" class="headerlink" title="Java8中新增的StringJoiner工具类"></a>Java8中新增的StringJoiner工具类</h2><blockquote><p>2022年5月26日15:35:21 <br><br>Java8中新增的StringJoiner工具类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringJoiner</span> <span class="variable">stringjoiner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;分割符&quot;</span>);</span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">stringjoiner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;分割符&quot;</span>,<span class="string">&quot;前缀delimiter&quot;</span>,<span class="string">&quot;后缀suffix&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JAVA基础" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JAVA基础" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://gitlab.com/1792097009gker/gkerhexoblog.git/2021/03/20/Spring/"/>
    <id>https://gitlab.com/1792097009gker/gkerhexoblog.git/2021/03/20/Spring/</id>
    <published>2021-03-20T03:15:41.000Z</published>
    <updated>2022-06-23T06:24:58.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Spring初识（一）"><a href="#Spring初识（一）" class="headerlink" title="Spring初识（一）"></a>Spring初识（一）</h2><hr><h3 id="框架、生态（框架衍生品）"><a href="#框架、生态（框架衍生品）" class="headerlink" title="框架、生态（框架衍生品）"></a>框架、生态（框架衍生品）</h3><hr><h3 id="控制反转（IOC）与依赖注入（DI）"><a href="#控制反转（IOC）与依赖注入（DI）" class="headerlink" title="控制反转（IOC）与依赖注入（DI）"></a>控制反转（IOC）与依赖注入（DI）</h3><blockquote><ul><li>提到Spring框架，不管是网上的资料或者是自己探索，在学习过程中避不开的两个概念一个是<strong>控制反转（IOC）</strong> 另一个是 <strong>依赖注入（DI）</strong> 但大都是讲述何为控制反转与依赖注入，最典型的代码是</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由 B 实体中通过new 直接进行对象的声明与赋值</span></span><br><span class="line">B &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在 B 实体中通过set方法实现对对象的赋值</span></span><br><span class="line">B&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a=a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也很迷惑采用<strong>IOC</strong>的好处，直到 <a href="https://www.zhihu.com/question/23277575/answer/24259844">https://www.zhihu.com/question/23277575/answer/24259844</a> 看到这篇文章</p><blockquote><ul><li>IOC容器（用于存放bean对象的容器）<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">?</span> <span class="attr">class</span>=<span class="string">?</span> <span class="attr">...</span>若干属性&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">?</span> <span class="attr">value</span>=<span class="string">?/</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">XXX</span> <span class="variable">xx</span> <span class="operator">=</span> ac.getBean(XXX.class);</span><br><span class="line">xx.method();</span><br></pre></td></tr></table></figure><blockquote><ul><li>使用ApplicationContext 将xml中的配置变为对象的过程：<blockquote><ol><li>加载xml</li><li>解析xml</li><li>封装BeanDefinition（类定义信息）</li><li>实例化</li><li>放入容器 </li><li>通过容器获取 </li></ol></blockquote></li></ul></blockquote><blockquote><ul><li>将bean存入容器的集合框架<blockquote><ol><li>采用Map容器 通过getBean(key)值获取对象<blockquote><ul><li>Map用于存放bean对象的方式 key 与 value值应该存放什么</li></ul></blockquote></li></ol></blockquote></li></ul></blockquote><table><thead><tr><th>k</th><th>v</th></tr></thead><tbody><tr><td>String</td><td>Object</td></tr><tr><td>Class</td><td>Object</td></tr><tr><td>String</td><td>ObjectFactory</td></tr><tr><td>String</td><td>BeanDefinition</td></tr></tbody></table><blockquote><ul><li>三级缓存【解决Spring中的循环依赖】<blockquote><ul><li>what 循环依赖</li><li>Spring中的bean对象默认都为单例模式，即在容器中，bean对象只允许存在一个，那么当出现以下情况下便会产生循环依赖。</li><li>A 对象中存在对于B对象的引用 b  B对象中存在对于A对象的引用a 无论是往容器中存放A或B对象时便会产生循环依赖，存放A时，检索B对象是否在容器中存在，若不存在需要创建B ，创建B时需要查看A对象是否在容器中创建。 </li></ul></blockquote></li></ul></blockquote><hr><h3 id="IOC的好处"><a href="#IOC的好处" class="headerlink" title="IOC的好处"></a>IOC的好处</h3><p>1.资源可由第三方直接进行配置与管理 **(IOC容器)**，这里所说的第三方是指不属于使用资源的双方。  </p><p>2.降低使用资源双方的依赖程度。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>1.生活中的网购，我们购买方需要买东西的时候（资源调用者），要借助于网购平台（第三方），而不是提供商品的工厂（资源提供者），反之，工厂想要卖物品时也只需跟第三方取得联系就可以。网购平台也可集中管理这些商品（bean）。<br>2.支付宝在网购交易流程中也属于一个第三方（IOC容器）。</p><h3 id="IOC-与-DI-的产生"><a href="#IOC-与-DI-的产生" class="headerlink" title="IOC 与 DI 的产生"></a>IOC 与 DI 的产生</h3><p>控制反转：资源双方互不依赖，资源调用时不依赖双方，活动由第三方负责管理。  </p><p>依赖注入：资源双方一方开放接口，在需要的时候，能够将另一注入进来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Spring" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/categories/Spring/"/>
    
    
    <category term="freemark" scheme="https://gitlab.com/1792097009gker/gkerhexoblog.git/tags/freemark/"/>
    
  </entry>
  
</feed>
