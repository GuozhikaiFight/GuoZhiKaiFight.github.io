{"meta":{"title":"gker's blog","subtitle":"","description":"笔记·学习","author":"GuoZhiKai","url":"https://gker.gitee.io/gkerblog","root":"/gkerblog/"},"pages":[{"title":"categories","date":"2021-03-22T13:33:33.000Z","updated":"2021-03-22T13:33:33.127Z","comments":true,"path":"categories/index.html","permalink":"https://gker.gitee.io/gkerblog/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-03-22T13:34:35.000Z","updated":"2021-03-22T13:34:35.158Z","comments":true,"path":"friends/index.html","permalink":"https://gker.gitee.io/gkerblog/friends/index.html","excerpt":"","text":""},{"title":"about","date":"2021-03-22T13:34:22.000Z","updated":"2021-03-22T13:34:22.265Z","comments":true,"path":"about/index.html","permalink":"https://gker.gitee.io/gkerblog/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-03-22T13:33:55.000Z","updated":"2021-03-22T13:33:55.682Z","comments":true,"path":"tags/index.html","permalink":"https://gker.gitee.io/gkerblog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构与算法-复杂度分析","slug":"数据结构与算法-复杂度分析","date":"2022-06-08T08:47:39.000Z","updated":"2022-06-08T08:53:31.334Z","comments":true,"path":"2022/06/08/数据结构与算法-复杂度分析/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","excerpt":"","text":"笼统解释下什么是数据结构与算法 数据结构：一组数据存储的结构 算法： 操作数据的一组方法数据结构与算法无法分而治之的原因在于，数据结构为算法服务，算法需要作用于特定的数据结构上 复杂度分析（衡量算法与代码执行效率的考量指标） 时间、控件复杂度分析方法（不依赖运行环境与测试数据，区别与事后统计法） 大O时间复杂度表示法 T(n) = O (f(n)) 推导过程 : 设代码执行时间为 T(n) 每行代码执行时间为 unit_time 为理想值 12345678int cal(int n) &#123; int sum = 0; int i = 1; for (; i &lt;= n; ++i) &#123; sum = sum + i; &#125; return sum;&#125; 1234567891011int cal(int n) &#123; int sum = 0; int i = 1; int j = 1; for (; i &lt;= n; ++i) &#123; j = 1; for (; j &lt;= n; ++j) &#123; sum = sum + i * j; &#125; &#125;&#125; [第一段] 代码执行时间推导 第一、第二行执行时间为一个unit_time for循环中执行时间 第三、第四行都为n个unit_time 即为 2n*unit_time 总时长为 T(n) = (2+2n)*unit_time [第二段] 代码执行时间推导 第一、第二、第三行执行时间为一个unit_time for循环中执行时间 第四、第五行都为n个unit_time 即为 2n* unit_time 第六、七执行时间为 n²* unit_time 总时长为 T(n) = (3+2n+2 ${n^2}$)*unit_time 结论 ： 代码执行时间T(n)与每行代码执行次数f(n)成正比即 T(n) = O (f(n)) 公式解析 T(n)代码执行总时长 n 为数据规模 f(n)每行代码执行次数和 O表示执行时间T(n)与f(n)成正比 上述例子代入公式 T(n) = O (2+2n) T(n) = O (3+2n+2 ${n^2}$) 公式精简过程 ：当 n无限大时 低阶、常数、系数 不左右增加趋势，只需记录最大数量级，时间复杂度为 T(n)= O(n) ; T(n) = O(${n^2}$) 复杂度分析法则 上述大O复杂度分析公式精简后，当n无限大时，时间复杂度分析方法中，只决定于数量级最大的部分，可忽略公式中的常数、系数、与低阶部分，只关注循环次数最多的一段代码。 加法法则 ： 总时间复杂度等于量级最大的代码时间复杂度 12345678910111213141516171819202122232425int cal(int n) &#123; int sum_1 = 0; int p = 1; for (; p &lt; 100; ++p) &#123; sum_1 = sum_1 + p; &#125; int sum_2 = 0; int q = 1; for (; q &lt; n; ++q) &#123; sum_2 = sum_2 + q; &#125; int sum_3 = 0; int i = 1; int j = 1; for (; i &lt;= n; ++i) &#123; j = 1; for (; j &lt;= n; ++j) &#123; sum_3 = sum_3 + i * j; &#125; &#125; return sum_1 + sum_2 + sum_3; &#125; 上述代码时间复杂度分为三段且忽略常数 第一段 忽略确定常数时间复杂度第二段 O(n) 第三段忽略系数与低阶 O(${n^2}$) 加法法则得出这段代码时间复杂度为 T(n) = O(${n^2}$) T1(n) = O(f(n)) T2(n) = O(g(n)) T(n) = T1(n)+T2(n) = Max(O(f(n)),O(g(n))) 乘法法则 ： 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 12345678910111213141516int cal(int n) &#123; int ret = 0; int i = 1; for (; i &lt; n; ++i) &#123; ret = ret + f(i); &#125; &#125; int f(int n) &#123; int sum = 0; int i = 1; for (; i &lt; n; ++i) &#123; sum = sum + i; &#125; return sum; &#125; 复杂度分析乘法法则推导 T(n)= O(cal(n))* O(f(n)) = O(${n^2}$) 复杂度量级 常量阶 O(1) O(1)可表示下方代码时间复杂度 123int i = 8;int j = 6;int sum = i + j; 对数阶 O($\\log{n}$) 线性对数阶 O(n $\\log{n}$) 下方代码执行次数最多的是第三行，执行次数由n决定 i的值为等比数列值 ${2^1}$ ${2^2}$ ${2^3}$ ${2^4}$ ${2^x}$ = n 即 x = $\\log{2^n}$ 与 $\\log{3^n}$ 对数阶时间复杂度可忽略底数标记为O($\\log{n}$)推导如下 $\\because$ $\\log{3^n}$ = $\\because$ $\\log{3^2}$ * $\\log{2^n}$ 又 $\\because$ 大O表示法忽略常数 $\\therefore$ T(n) = O(C*$\\log{2^n}$) O(Cf(n))=O(f(n)) $\\therefore$ T(n) = O($\\log{n}$) 线性对数阶在对数阶基础上循环执行n遍 12345678910//1 i=1; while (i &lt;= n) &#123; i = i * 2; &#125;//2 i=1; while (i &lt;= n) &#123; i = i * 3; &#125; 线性阶 O(n) 平方阶 O(${n^2}$) 、立方阶 O(${n^3}$) 、k次方阶 O(${n^k}$) 指数阶 O(${2^n}$) [非多项式量级] 阶乘阶段 O(n!) [非多项式量级]","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://gker.gitee.io/gkerblog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://gker.gitee.io/gkerblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Hexo简单搭建过程以及使用命令","slug":"Hexo简单搭建过程以及使用命令","date":"2022-06-07T08:31:54.000Z","updated":"2022-06-07T08:49:58.714Z","comments":true,"path":"2022/06/07/Hexo简单搭建过程以及使用命令/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/06/07/Hexo%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"环境安装 Node.js 安装完成后使用cmd执行 node -v 检查是否安装成功 下载cnpm 淘宝镜像源 npm install -g cnpm –registry=https://registry.npm.taobao.org 查看版本 cnpm -v 使用淘宝镜像源下载 hexo博客 cnpm install -g hexo-cli 查看hexo版本 hexo -v 创建空文件夹用于存放博客内容 hexo init windows下使用命令 启动hexo服务 hexo s 新建博客 hexo n “名称” 重新生成博客 hexo clean hexo g 下载用于推送到git的插件 cnpm install –save hexo-deployer-git hexo d 推送到远端","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://gker.gitee.io/gkerblog/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://gker.gitee.io/gkerblog/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"Java中的静态变量","slug":"Java中的静态变量","date":"2022-05-28T08:13:49.000Z","updated":"2022-06-07T09:59:36.760Z","comments":true,"path":"2022/05/28/Java中的静态变量/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/05/28/Java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/","excerpt":"","text":"Java中的静态变量 Java中的静态变量也叫作类变量,被关键字static修饰 静态变量可以不被赋值，java会分配一个初始值 静态变量命名规范：一般使用全字母大写与下划线进行分割 静态变量不会随着变量的创建而创建，属于类 Java中的静态方法 类方法，无this自引用使用，可操作形参与静态变量（自身的静态变量或者其他类的静态变量） Java中的静态方法的重载","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://gker.gitee.io/gkerblog/categories/JAVA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://gker.gitee.io/gkerblog/tags/JAVA%E5%9F%BA%E7%A1%80/"}]},{"title":"动态代理是基于什么原理？","slug":"动态代理是基于什么原理？","date":"2022-05-26T07:41:02.000Z","updated":"2022-06-07T10:08:17.698Z","comments":true,"path":"2022/05/26/动态代理是基于什么原理？/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/05/26/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/","excerpt":"","text":"动态代理是基于什么原理？ 从编程语言分类角度来讲，按照语言类型信息是在运行时检查，还是编译期检查分为动态类型和静态类型的编程语言 不同类型变量赋值时，是否需要显示地（强制）进行类型转换可区分是否是所谓的强类型或弱类型语言。Java语言是静态的强类型语言，但因为反射的存在，也具备部分动态语言的能力。 Java中的反射机制 反射机制是Java语言提供的一种基础功能，赋予程序在运行时的自省能力，通过反射我们可以直接操作类，或者对象，获取类的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。 动态代理 运行时动态构建代理、动态处理代理方法调用的机制【包装RPC调用、AOP（面向切面编程）】 实现动态代理的方式 JDK中主要利用反射机制、其他实现方式如：传说中更高性能的字节码操作机制、类似ASM、cglib、JavaSsist AccessibleObject.setAccessible​ 1AccessibleObject.setAccessible​(boolean flag) 反射中需要显示更改setAccessible的值进行私有属性的获取、或者方法的获取，需要设置为true O/R Mapping 框架中，为一个Java实体对象，运行时自动生成setter、getter逻辑 绕过API访问控制 Java9以后，出于强封装性的考虑，对反射访问进行了限制，Jigsaw引入了Open的概念，只有当被反射操作的模块和指定的包对反射调用者模块Open，才能使用setAccessible 动态代理","categories":[{"name":"JAVA基础面试题","slug":"JAVA基础面试题","permalink":"https://gker.gitee.io/gkerblog/categories/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"JAVA基础面试题","slug":"JAVA基础面试题","permalink":"https://gker.gitee.io/gkerblog/tags/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"String、StringBuilder、StringBuffer有什么区别","slug":"String、StringBuilder、StringBuffer有什么区别","date":"2022-05-26T07:38:12.000Z","updated":"2022-06-07T10:08:28.007Z","comments":true,"path":"2022/05/26/String、StringBuilder、StringBuffer有什么区别/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/05/26/String%E3%80%81StringBuilder%E3%80%81StringBuffer%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"String、StringBuilder、StringBuffer有什么区别 Java每日一记1 内容更改 Java8中新增的StringJoiner工具类 12StringJoiner stringjoiner = new StringJoiner(&quot;分割符&quot;);StringJoiner stringjoiner = new StringJoiner(&quot;分割符&quot;,&quot;前缀delimiter&quot;,&quot;后缀suffix&quot;); String 类在java中是典型的immutable类 类被声明为final,属性也被final修饰，由于不可变性，对于字符串拼接、裁剪等动作时，都会产生新的String对象。 StringBuffer 为解决上述拼接中产生太多对象问题而提供的类，本质上是一个线程安全的可修改字符序列 StringBuilder 在能力上与StringBuffer没有本质区别，但去掉了线程安全的部分。 String 是典型的immutable类的典型实现，原生保证了线程安全 (1) String的创建机理 由于String在Java世界中使用过于频繁，Java为了避免在一个系统中产生大量的String对象，引入了字符串常量池。其运行机制是：创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建直接从池中刚查找到的对象引用；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。 123举例：String str1 = &quot;123&quot;; //通过直接量赋值方式，放入字符串常量池String str2 = new String(“123”);//通过new方式赋值方式，不放入字符串常量池 注意：String提供了inter()方法。调用该方法时，如果常量池中包括了一个等于此String对象的字符串（由equals方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并且返回此池中对象的引用。 (2) String的特性 [A] 不可变。是指String对象一旦生成，则不能再对它进行改变。不可变的主要作用在于当一个对象需要被多线程共享，并且访问频繁时，可以省略同步和锁等待的时间，从而大幅度提高系统性能。不可变模式是一个可以提高多线程程序的性能，降低多线程程序复杂度的设计模式。[B] 针对常量池的优化。当2个String对象拥有相同的值时，他们只引用常量池中的同一个拷贝。当同一个字符串反复出现时，这个技术可以大幅度节省内存空间。 StringBuffer 的线程安全是通过把各种修改数据的方法都加上了synchronized关键字实现的 StringBuffer与StringBuilder底层都是利用可修改的char数组（java9以后是byte数组）区别是最终方法是否加了synchronized","categories":[{"name":"JAVA基础面试题","slug":"JAVA基础面试题","permalink":"https://gker.gitee.io/gkerblog/categories/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"JAVA基础面试题","slug":"JAVA基础面试题","permalink":"https://gker.gitee.io/gkerblog/tags/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"强引用、软引用、弱引用、幻象引用有什么区别?","slug":"强引用、软引用、弱引用、幻象引用有什么区别","date":"2022-05-26T01:53:15.000Z","updated":"2022-06-07T10:08:11.258Z","comments":true,"path":"2022/05/26/强引用、软引用、弱引用、幻象引用有什么区别/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/05/26/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"强引用、软引用、弱引用、幻象引用有什么区别 Java中将除基本数据类型意外的各类对象的对象引用，按其生命周期的长短，将其分为四类 各种引用 不同引用类型体现的是对象不同的可达性和对垃圾收集的影响 强引用 （Strong reference） 即普通的对象引用，存在强引用指向的对象，垃圾收集器不会碰这种对象 通过new 关键字创建的对象所关联的引用就是强引用，当JVM内存空间不足时，JVM宁愿抛出OutOfMemoryError运行时错误，也不随意回收强引用对象。 普通对象，如果没有其他引用关系，只要超过了引用的作用域或显式将强引用赋值为null，就是可以被垃圾收集。 软引用 （SoftReference） 相对于强引用来讲弱化一点的引用,当JVM认为内存不足时，才会去试图回收软引用对象，JVM会确保在抛出OutOfMemoryError之前，清理软引用指向对象。 一般应用于实现内存敏感的缓存 弱引用 （WeakReference） 提供一种访问在弱引用状态下对象的途径 ，不管当前内存空间是否足够，都会回收它的内存 幻象引用（虚引用）（PhantomReference） 无法通过该引用获取对象，仅仅提供一种确保对象被finalize以后，做某些事情的机制 引用队列 ReferenceQueue 我们在创建各种引用并关联到相应对象时，可选择是否需要关联引用队列，JVM会在特定时机将引用enqueue到队列中，我们可以从队列里获取引用并进行相关后续逻辑。 1234567891011121314Object counter = new Object();ReferenceQueue refQueue = new ReferenceQueue&lt;&gt;();PhantomReference&lt;Object&gt; p = new PhantomReference&lt;&gt;(counter, refQueue);counter = null;System.gc();try &#123; // Remove是一个阻塞方法，可以指定timeout，或者选择一直阻塞 Reference&lt;Object&gt; ref = refQueue.remove(1000L); if (ref != null) &#123; // do something &#125;&#125; catch (InterruptedException e) &#123; // Handle it&#125; 软引用，弱引用可与引用队列联合使用，当相应引用的对象被垃圾回收器回收，JVM会把软引用加入到关联的引用队列中。 虚引用必须要与引用队列联合使用，程序可通过判断引用队列中师傅已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收，若已被加入到队列，name可在被引用的对象在内存回收之前采取一些程序行动。 对象声明周期与不同可达性状态 强可达 （Strongly Reachable） 当一个对象可以有一个或多个线程不通过各种引用访问到的情况（新创建一个对象，那么创建它的线程对它就是强可达） 软可达 (Softly Reachable) 只能通过软引用才能访问到对象的状态 弱可达 (Weakly Reachable) 无法通过强引用或软引用访问，只能通过弱引用访问时的状态 幻象可达 (Phantom Reachable) 没有强、软、弱引用关联，并且finalize过了，只有幻象引用指向这个对象 不可达 (unreachable) 对象被清除","categories":[{"name":"JAVA基础面试题","slug":"JAVA基础面试题","permalink":"https://gker.gitee.io/gkerblog/categories/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"JAVA基础面试题","slug":"JAVA基础面试题","permalink":"https://gker.gitee.io/gkerblog/tags/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"final finally finalize 有何不同?","slug":"final-finally-finalize-有何不同","date":"2022-05-26T01:52:12.000Z","updated":"2022-06-07T10:08:54.781Z","comments":true,"path":"2022/05/26/final-finally-finalize-有何不同/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/05/26/final-finally-finalize-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C/","excerpt":"","text":"final finally finalize 有何不同 final final修饰符可修饰类、方法、变量 类无法被继承、方法不可被重写、变量不可被修改 final关键字经常大量出现在源码或第三方类库中，可有效避免API使用者更改基础功能，在并发编程中有利于减少额外的同步开销。 final只可约束相关变量引用不可以被赋值，但final修饰的对象行为不会被final影响 finally 保证重点代码一定被执行的一种机制 以下代码finally不会被执行 12345678try&#123; System.exit(1); &#125;catch()&#123;&#125;finally&#123; System.out.println(&quot;print from finally&quot;);&#125; finalize 保证对象在被垃圾收集前完成特定资源的回收，java9开始被标记为deprecated（不赞成）","categories":[{"name":"JAVA基础面试题","slug":"JAVA基础面试题","permalink":"https://gker.gitee.io/gkerblog/categories/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"JAVA基础面试题","slug":"JAVA基础面试题","permalink":"https://gker.gitee.io/gkerblog/tags/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"java 中的 Exception 与 Error","slug":"java-中的-Exception-与-Error","date":"2022-05-26T01:48:55.000Z","updated":"2022-06-07T10:08:40.757Z","comments":true,"path":"2022/05/26/java-中的-Exception-与-Error/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/05/26/java-%E4%B8%AD%E7%9A%84-Exception-%E4%B8%8E-Error/","excerpt":"","text":"Exception Error区别 Java中的Throwable Exception Error设计与分类 典型回答：Exception 与 Error都继承了Throwable类，在Java中只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch）Exception是程序正常运行中可预料的意外情况，可能并应当进行捕获。 checked （可检查异常）：编译期的一部分unchecked （不可检查异常）：运行时异常类似NullPointerException 可通过相关逻辑进行避免Error 是程序处于非正常、不可恢复状态，所以不便进行捕获。 常见Exception 与 Error Exception (checked Exception) IOException Exception (RuntimeException) NullPointerException （空指针） ClassCastException（类型转换异常） SecurityException （） ArrayIndexOutofBoundsException Error (虚拟机错误：VirtualMachineError) OutOfMemoryError （内存溢出错误） StackOverflowError （堆栈溢出错误） Error (链接错误 LinkageError) NoClassDefFoundError UnsatisfiedLinkError ExceptionInIInitiallizerError 面试题 NoClassDefFoundError 与 ClassNotFoundException 一个Error一个Exception ClassNotFoundException 是在java中显示类加载时（编译过程中）产生的，产生原因如下 Class.forName() ClassLoader中的findSystemClass() ClassLoader中的loadClass() NoClassDefFoundError 错误发生的原因是因为Java虚拟机在编译期间可找到合适的类，但在运行时找不到合适的类 异常处理原则 尽可能不要捕获泛泛Exception,代码中存在的具体可确定异常类型需要进行具体类型的捕获。 123456try&#123; // Thread.sleep(1000L);&#125;catch()&#123; // do something&#125; 生吞异常,无日志输出 12345try&#123; //业务代码&#125;catch(Exception e)&#123; e.printStackTrace();&#125;","categories":[{"name":"JAVA基础面试题","slug":"JAVA基础面试题","permalink":"https://gker.gitee.io/gkerblog/categories/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"JAVA基础面试题","slug":"JAVA基础面试题","permalink":"https://gker.gitee.io/gkerblog/tags/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"JVM-03-java虚拟机如何加载class类","slug":"JVM-03-java虚拟机如何加载class类","date":"2022-05-19T09:32:15.000Z","updated":"2022-05-20T01:31:00.036Z","comments":true,"path":"2022/05/19/JVM-03-java虚拟机如何加载class类/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/05/19/JVM-03-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDclass%E7%B1%BB/","excerpt":"","text":"Java中的基本数据类型 为什么在谈论Java虚拟机时如何加载class类时会优先谈关于Java的数据类型的话题？ 在java中除去基本数据类型还存在引用数据类型，但基本数据类型已经由Java虚拟机预先定义完成，刨除基本数据类型后，存在的引用数据类型分为以下四类 类 接口 数组 泛型参数真正经由jvm进行加载的引用类型只有类、与接口两类，并且都有对应的字节流。而jvm类加载过程，实际上是查找对应字节流，并将其加载到内存中调用的过程。 Java中的类主要加载过程 类的加载过程主要有 加载 : jvm虚拟机借助类加载器查找类字节流文件并创建的过程 链接 : 将创建完成的类合并到虚拟机中使类可以执行的过程 验证 ：确保加载的类满足java虚拟机约束规范 准备 ：为被加载类的静态字段分配内存,部分java虚拟机会生构造与其他类层次相关的数据结构 解析 ：将符号引用解析为实际引用 初始化 ：为标记为常量值的字段赋值，以及执行&lt;clinit&gt;的过程 Java中的类加载过程 - 加载 jvm中的类加载器 启动类加载器 【bootstrap class loader】启动类加载器由C++ 编写，在java中无对应对象 扩展类加载器 【extension class Loader】 （父类为启动类加载器） 应用类加载器 【application class loader】（父类扩展类加载器） 双亲委派机制 当类加载器接到加载java类加载请求后，当前类加载器会首先将请求转发给其父类的类加载器，父类的类加载器会尝试进行类的查找，当无法找到对应类的字节流后会将请求重新发送给当前类加载器，并尝试进行类字节流信息的查找。 java9之前各种类加载器加载的内容 启动类加载器 : jre lib目录下jar包中的类 以及由虚拟机参数 -Xbootclasspath指定的类 扩展类加载器 : jre lib ext目录下jar包中的类 以及系统变量 java.ext.dirs指定的类 应用类加载器 : 负责加载应用程序路径（虚拟机参数 -cp/-classpath、系统变量java.class.path或环境变量classpath所指定的路径）下的类 java9模块系统 扩展类加载器更名为平台类加载器 除javase中几个关键模块 (javabase)其他均由平台加载器加载 Java中的类加载过程 - 链接 链接-准备过程中当引用此类本身的方法，属性或引用其他方法、字段时，Java编译器会生成一个符号引用。 链接-解析、解析过程中当符号引用指向一个未被加载的类、或者未被加载类的字段或方法时，解析将触发这个类的加载（未必触发这个类的链接以及初始化） Java中的类加载过程 - 初始化 ConstantValue 常量值 在Java代码中，如果在初始化一个静态字段时直接对其声明、赋值，并且该静态字段被final修饰，数据类型为基本数据类型或字符串时，Java编译器会将其标记为常量值，初始化直接由虚拟机完成。&lt;clinit&gt; 除上述之外的直接赋值操作，以及所有静态代码块中的代码，会被java编译器置于同一方法中，并被命名为&lt;clinit&gt;类初始化完成后，才会成为可执行状态。","categories":[{"name":"JVM","slug":"JVM","permalink":"https://gker.gitee.io/gkerblog/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://gker.gitee.io/gkerblog/tags/JVM/"}]},{"title":"Java中的注解与反射","slug":"Java中的注解与反射","date":"2022-05-15T12:35:40.000Z","updated":"2022-06-07T09:59:32.593Z","comments":true,"path":"2022/05/15/Java中的注解与反射/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/05/15/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/","excerpt":"","text":"注解 Annotation 基本格式： @ 注释名 使用位置： package class method filed上 内置注解(Java本身自带的注解) @Override 重写 不做解释 @Deprecated 不鼓励使用这样的元素 @SuppressWarnings 镇压警告信息 可传参 元注解 解释其他注解的注解 @Target 描述注解使用范围 @Retention Source &lt; Class &lt; Runtime @Document 注解将被包含在javadoc中 @Inherited 子类可继承父类中的该注解 自定义注解 自定义注解格式 修饰符 @interface 注解名{定义内容} 1234public @interface CeshiAnnotation&#123; //参数类型 参数名 ps:自定义注解的格式跟接口中的方法定义类似但实际意义不同 String value();&#125; 反射 reflectionJava中的反射机制 增加了Java语言的动态机制，反射机制允许程序执行期间借助Reflection API获取类的内部信息 java语言中，反射机制的出现使得class文件在程序执行过程中也可获取类的全部信息 反射精髓在于“反”字，可通过对象反推获取相关类信息 Java中获取Class对象实例的方式1234567public static void main(String[] args)&#123; Class&lt;?&gt; c1 = Person.class; System.out.pringln(c1);&#125;class Person&#123; private String name;&#125; 12345678public static void main(String[] args)&#123; Person person = new Person(); Class&lt;?&gt; c1 = person.getClass(); System.out.pringln(c1);&#125;class Person&#123; private String name;&#125; 1234567public static void main(String[] args)&#123; Class&lt;?&gt; c1 = Class.forName(&quot;类名路径&quot;); System.out.pringln(c1);&#125;class Person&#123; private String name;&#125; 12//此方法只对Java基本数据类型的包装类有效Class&lt;?&gt; c1 = Integer.TYPE; 哪些类型可以有Class类 java中的对象基本都可以获取到class类型，例如 内部类、接口、数组、枚举、注解、基本数据类型、void","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://gker.gitee.io/gkerblog/categories/JAVA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://gker.gitee.io/gkerblog/tags/JAVA%E5%9F%BA%E7%A1%80/"}]},{"title":"GIT知识","slug":"GIT知识","date":"2022-05-08T02:31:12.000Z","updated":"2022-05-14T02:41:15.070Z","comments":true,"path":"2022/05/08/GIT知识/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/05/08/GIT%E7%9F%A5%E8%AF%86/","excerpt":"","text":".git目录文件 HEAD文件 存放当前Git工作指向分支 ：ref: refs/heads/master 切换路径后会发生变化 config文件 本地仓库配置信息，会设置在config文件中 refs文件 1 heads 分支 heads分支文件中会存在多个文件，每个文件中存放的类似指针，会指向相应commit 2 tags 里程碑 objects 存放对象 git对象之间的关系 commit tree blob commit 每次变更后会产生一个commit对象 一个commit对应一棵树 tree tree 视图 当前commit对应项目此时全部的文件快照 (文件夹) blob 文件 文件内容相同git中只有一份 与文件名无关","categories":[{"name":"Git 基础","slug":"Git-基础","permalink":"https://gker.gitee.io/gkerblog/categories/Git-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Git 基础","slug":"Git-基础","permalink":"https://gker.gitee.io/gkerblog/tags/Git-%E5%9F%BA%E7%A1%80/"}]},{"title":"GIT基础命令","slug":"GIT基础","date":"2022-04-30T12:07:45.000Z","updated":"2022-05-08T03:22:00.062Z","comments":true,"path":"2022/04/30/GIT基础/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/04/30/GIT%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Windows中的cmd命令 cls 清屏 GIT基础命令 git config –global/local/system 设置命令除了作用域不一致其他都相同 1 git –verison 查看GT版本 2 git config –global –list 查看git用户信息 3 git config –global user.name ‘your_name’ 4 git config –global user.email ‘your_email@邮箱地址’ GIT 命令 config 命令local参数设置优先级高于global 1 git config –local local只对某个仓库有效 1 git config –local user.name 查看当前仓库配置的用户名 2 git config –local user.name ‘需要设置的用户名’ 修改配置信息用户名 2 git config –global global对当前用户下所有仓库有效 3 git config –system system对系统所有登录的用户有效 显示 config 配置 1 git config –list –local 2 git config –list –global 3 git config –list –system 创建Git仓库 新建项目直接使用Git管理 1 进入新项目目标文件夹 2 git init project_name 使用Git新增并提交文件 1 git add 文件名 管控需要新增的文件 2 git commit -m ‘新增理由’ 提交新增的文件 3 git status git状态 使用Git对修改的文件提交到暂存区 1 git add -u 被git管控的文件提交到暂存区 -u update Git 对文件重命名操作 1 Git新增重命名文件并删除原名称文件 1 git rm 文件名称 2 git add 新文件名称 3 git commit -m “” 2 Git一条命令替换上面三条 1 git mv 旧文件名 新文件名 查看Git日志或版本历史 git log 命令图形化查看 –graph 1 git log –oneline 简短历史 2 git log -n条数 –oneline 设置选择查看条数的简短历史 3 git log –oneline –all 查看全部分支的历史 4 git log –oneline –all -n条数 查看全部分支的历史的某几条 Git 分支操作 1 git branch -v 查看本地git有多少分支 2 git checkout 分支名称 切换分支 Git暂存区 Git暂存区中的文件可以记录文件每次变更的地方 Git 通过文件Hash数值查看文件类型和内容 git cat-file -t hash值 类型 git cat-file -p hash值 内容 Git web版帮助文档查看git help –web 命令 ps: git help –web log","categories":[{"name":"Git 基础","slug":"Git-基础","permalink":"https://gker.gitee.io/gkerblog/categories/Git-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Git 基础","slug":"Git-基础","permalink":"https://gker.gitee.io/gkerblog/tags/Git-%E5%9F%BA%E7%A1%80/"}]},{"title":"JVM-01-java代码是如何运行的","slug":"JVM-01-java代码是如何运行的","date":"2022-04-27T07:51:04.000Z","updated":"2022-05-19T09:32:20.051Z","comments":true,"path":"2022/04/27/JVM-01-java代码是如何运行的/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/04/27/JVM-01-java%E4%BB%A3%E7%A0%81%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/","excerpt":"","text":"01 | JAVA中的JVM是如何识别运行高级语言所编写的代码的？ 三个问题 我们对于JAVA所宣传的“一次编译，到处运行”是怎样理解的呢？ JAVA作为一门高度抽象的语言，在经过成熟的IDE编写后，那些能被我们所看懂的代码，到底是如何在JVM中运行的呢？ JAVA语言到底是编译执行还是解释执行？ Write once, run anywhere 我们在学习JVM的时候，绕不过去的是JAVA中关于JRE（Java Runtime Environment ）与JDK(Java Development Kit )的定义JVM位于JRE中 JDK又包含JRE,（Write once, run anywhere）纠其实现原因也绕不JVM,不同于C++，(C++可将编写完成的代码直接编译成机器码)Java代码经过程序员（人类）的编写后，产生的代码计算机并不能看懂，Java通过javac命令的编译后，会将由人类可以看懂的程序指令编译为JVM虚拟机可以看懂的 .class 结尾的字节码文件，再由JVM虚拟机将其翻译成计算机可以看懂的 机器码，并最终执行。JVM可以将程序员所编写的代码部署到不同系统的计算机上，整个过程，开发人员只需要编写一次代码，并将.class文件交给不同系统中的JVM即可，充分与硬件环境之间进行解耦操作。 JVM虚拟机中是如何运行字节码文件的？ 摘自极客时间《深入拆解JAVA虚拟机 》 在主流Java版本中以HotSpot虚拟机为例，JVM虚拟机在接收到class字节码文件后，首先通过类加载器（Class-Loader）加载字节码文件，（ps:省略具体加载过程）加载后的Java类会被存放于方法区，代码运行过程中会JVM会执行方法区中的代码。 JVM在运行Java代码时，会在计算机内存中划分栈与堆来存储数据，在栈中会分为面向Java方法的Java方法栈，本地方法的本地方法栈，以及存放各个线程执行位置的PC寄存器 JVM虚拟机如何将字节码文件翻译为机器码？ 在HotSpot虚拟机中，翻译为机器码的过程有两种形式 解释执行 ：将字节码逐条翻译并执行 即使编译（JUST-In-Time compilation JIT） ： 将字节码全部编译完成机器码后执行 HotSpot默认采用混合模式（-Xmixed）进行编译,通过内置的两个不同的JIT compiler 即 C1 C2 以及 Graal jaotc工具等 内置多个编译器是为了可让用户针对不同的需求进行相应的取舍，C1 为Client 模式，适用于对启动速度敏感的应用，C2对应Server模式，除了常见的Java使用模式外，还有一种新的编译方式，即所谓的AOT(Ahead-of-Time Compilation),直接将字节码编译成机器码。","categories":[{"name":"JVM","slug":"JVM","permalink":"https://gker.gitee.io/gkerblog/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://gker.gitee.io/gkerblog/tags/JVM/"}]},{"title":"Java每日一记","slug":"Java每日疑惑","date":"2022-04-07T12:42:18.000Z","updated":"2022-06-07T09:59:28.267Z","comments":true,"path":"2022/04/07/Java每日疑惑/","link":"","permalink":"https://gker.gitee.io/gkerblog/2022/04/07/Java%E6%AF%8F%E6%97%A5%E7%96%91%E6%83%91/","excerpt":"","text":"Java8中新增的StringJoiner工具类 2022年5月26日15:35:21 Java8中新增的StringJoiner工具类 12StringJoiner stringjoiner = new StringJoiner(&quot;分割符&quot;);StringJoiner stringjoiner = new StringJoiner(&quot;分割符&quot;,&quot;前缀delimiter&quot;,&quot;后缀suffix&quot;);","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://gker.gitee.io/gkerblog/categories/JAVA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://gker.gitee.io/gkerblog/tags/JAVA%E5%9F%BA%E7%A1%80/"}]},{"title":"Spring","slug":"Spring","date":"2021-03-20T03:15:41.000Z","updated":"2021-03-31T12:50:10.077Z","comments":true,"path":"2021/03/20/Spring/","link":"","permalink":"https://gker.gitee.io/gkerblog/2021/03/20/Spring/","excerpt":"","text":"Spring初识（一） 控制反转（IOC）与依赖注入（DI）提到Spring框架，不管是网上的资料或者是自己探索，在学习过程中避不开的两个概念一个是控制反转（IOC） 另一个是 依赖注入（DI） 但大都是讲述何为控制反转与依赖注入，最典型的代码是 1234567891011//由 B 实体中通过new 直接进行对象的声明与赋值B &#123; A a = new A();&#125;//在 B 实体中通过set方法实现对对象的赋值B&#123; A a; public void setA(A a)&#123; this.a=a; &#125;&#125; 我也很迷惑采用IOC的好处，直到 https://www.zhihu.com/question/23277575/answer/24259844 看到这篇文章 IOC的好处1.资源可由第三方直接进行配置与管理 **(IOC容器)**，这里所说的第三方是指不属于使用资源的双方。 2.降低使用资源双方的依赖程度。 举个栗子1.生活中的网购，我们购买方需要买东西的时候（资源调用者），要借助于网购平台（第三方），而不是提供商品的工厂（资源提供者），反之，工厂想要卖物品时也只需跟第三方取得联系就可以。网购平台也可集中管理这些商品（bean）。2.支付宝在网购交易流程中也属于一个第三方（IOC容器）。 IOC 与 DI 的产生控制反转：资源双方互不依赖，资源调用时不依赖双方，活动由第三方负责管理。 依赖注入：资源双方一方开放接口，在需要的时候，能够将另一注入进来。","categories":[{"name":"Spring","slug":"Spring","permalink":"https://gker.gitee.io/gkerblog/categories/Spring/"}],"tags":[{"name":"freemark","slug":"freemark","permalink":"https://gker.gitee.io/gkerblog/tags/freemark/"}],"author":"gker"},{"title":"TomCat杂项","slug":"TomCat杂项","date":"2021-03-20T03:15:41.000Z","updated":"2021-03-31T12:54:47.104Z","comments":true,"path":"2021/03/20/TomCat杂项/","link":"","permalink":"https://gker.gitee.io/gkerblog/2021/03/20/TomCat%E6%9D%82%E9%A1%B9/","excerpt":"","text":"Tomcat杂项 Tomcat简单来讲是一个Web服务器，同时也是一个存放JSP与SERLVET的容器 Tomcat中不常见的操作1. 配置虚拟目录配置虚拟目录的产生是因为如果存在多个Web站点，并且在服务器资源有限的情况之下，依照默认的做法需要将所有的Web站点存放于WebApps目录之下，这样会导致服务器资源更加紧张。不利于单个Web站点的管理。 针对上述场景的产生，需要将Web站点进行分散，并需要将分散所创建的路径（目录）交给Web服务器管理（Tomcat） : 虚拟目录的映射 2. 配置虚拟主机配置虚拟主机是解决多个网站多个域名公用一台服务器的场景，一般来讲一个Tomcat只运行一个网站。","categories":[{"name":"TomCat","slug":"TomCat","permalink":"https://gker.gitee.io/gkerblog/categories/TomCat/"}],"tags":[{"name":"WEB应用服务器","slug":"WEB应用服务器","permalink":"https://gker.gitee.io/gkerblog/tags/WEB%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://gker.gitee.io/gkerblog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://gker.gitee.io/gkerblog/categories/Hexo%E5%8D%9A%E5%AE%A2/"},{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://gker.gitee.io/gkerblog/categories/JAVA%E5%9F%BA%E7%A1%80/"},{"name":"JAVA基础面试题","slug":"JAVA基础面试题","permalink":"https://gker.gitee.io/gkerblog/categories/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"JVM","slug":"JVM","permalink":"https://gker.gitee.io/gkerblog/categories/JVM/"},{"name":"Git 基础","slug":"Git-基础","permalink":"https://gker.gitee.io/gkerblog/categories/Git-%E5%9F%BA%E7%A1%80/"},{"name":"Spring","slug":"Spring","permalink":"https://gker.gitee.io/gkerblog/categories/Spring/"},{"name":"TomCat","slug":"TomCat","permalink":"https://gker.gitee.io/gkerblog/categories/TomCat/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://gker.gitee.io/gkerblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://gker.gitee.io/gkerblog/tags/Hexo%E5%8D%9A%E5%AE%A2/"},{"name":"JAVA基础","slug":"JAVA基础","permalink":"https://gker.gitee.io/gkerblog/tags/JAVA%E5%9F%BA%E7%A1%80/"},{"name":"JAVA基础面试题","slug":"JAVA基础面试题","permalink":"https://gker.gitee.io/gkerblog/tags/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"JVM","slug":"JVM","permalink":"https://gker.gitee.io/gkerblog/tags/JVM/"},{"name":"Git 基础","slug":"Git-基础","permalink":"https://gker.gitee.io/gkerblog/tags/Git-%E5%9F%BA%E7%A1%80/"},{"name":"freemark","slug":"freemark","permalink":"https://gker.gitee.io/gkerblog/tags/freemark/"},{"name":"WEB应用服务器","slug":"WEB应用服务器","permalink":"https://gker.gitee.io/gkerblog/tags/WEB%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]}